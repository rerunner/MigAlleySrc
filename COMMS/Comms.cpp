/*
	 MiG Alley
	 Copyright (C) 1998, 1999, 2000, 2001 Empire Interactive (Europe) Ltd,
	 677 High Road, North Finchley, London N12 0DA

	 Please see the document licence.doc for the full licence agreement

2. LICENCE
 2.1 	
 	Subject to the provisions of this Agreement we now grant to you the 
 	following rights in respect of the Source Code:
  2.1.1 
  	the non-exclusive right to Exploit  the Source Code and Executable 
  	Code on any medium; and 
  2.1.2 
  	the non-exclusive right to create and distribute Derivative Works.
 2.2 	
 	Subject to the provisions of this Agreement we now grant you the
	following rights in respect of the Object Code:
  2.2.1 
	the non-exclusive right to Exploit the Object Code on the same
	terms and conditions set out in clause 3, provided that any
	distribution is done so on the terms of this Agreement and is
	accompanied by the Source Code and Executable Code (as
	applicable).

3. GENERAL OBLIGATIONS
 3.1 
 	In consideration of the licence granted in clause 2.1 you now agree:
  3.1.1 
	that when you distribute the Source Code or Executable Code or
	any Derivative Works to Recipients you will also include the
	terms of this Agreement;
  3.1.2 
	that when you make the Source Code, Executable Code or any
	Derivative Works ("Materials") available to download, you will
	ensure that Recipients must accept the terms of this Agreement
	before being allowed to download such Materials;
  3.1.3 
	that by Exploiting the Source Code or Executable Code you may
	not impose any further restrictions on a Recipient's subsequent
	Exploitation of the Source Code or Executable Code other than
	those contained in the terms and conditions of this Agreement;
  3.1.4 
	not (and not to allow any third party) to profit or make any
	charge for the Source Code, or Executable Code, any
	Exploitation of the Source Code or Executable Code, or for any
	Derivative Works;
  3.1.5 
	not to place any restrictions on the operability of the Source 
	Code;
  3.1.6 
	to attach prominent notices to any Derivative Works stating
	that you have changed the Source Code or Executable Code and to
	include the details anddate of such change; and
  3.1.7 
  	not to Exploit the Source Code or Executable Code otherwise than
	as expressly permitted by  this Agreement.

questions about this file may be asked at http://www.simhq.com/
*/

//------------------------------------------------------------------------------
//Filename       comms.cpp
//System         
//Author         Andrew McRae
//Date           Mon 23 Sep 1996
//Description    All Comms Init Stuff Prior to Sending Init Packets
//------------------------------------------------------------------------------

#define INITGUID
#define	F_COMMON
#define IDIRECTPLAY2_OR_GREATER
#include	"DOSDefs.H"
#include	<stdio.h>
#include	<stdlib.h>

#include	"dplay.h"
#include	"dplobby.h"

#include "mmsystem.h"

#include	"myerror.h"

#include	"worldinc.h"
#include	"uniqueID.h"
#include	"files.g"
#include	"text.h"
#include	"3dinstr.h"
#include	"savegame.h"
#include	"winmove.h"

#include	"misssub.h"
#include	"comms.h"

#include	"cbuffer.h"
#include	"aggrgtor.h"
#include	"missman2.h"
#include	"Mytime.h"
#include	"globrefs.h"
#include	"stub3d.h"
#include	"ctimeout.h"
#include	"..\mfc\resource.h"
#include	"replay.h"
#include	"bstream.h"
#include	"rchatter.h"
#include	"persons2.h"
#include	"overlay.h"
#include	"miles.h"

//STATICS!!!

H2HPlayerInfo DPlay::H2H_Player[MAXPLAYERS];

DPlay _DPlay;

//NOTE: the following GUID was generated by guidgen.exe

// {38305683-01EB-11d2-B1A4-004005247C2D}

// for lobbied games the GUID defined here is not used, the registry entry is instead
// used to find games. This must be altered by the install program.

#ifndef	MIG_DEMO_VER
#include <initguid.h> //RERUN
DEFINE_GUID(MIGALLEY_GUID, 
0x38305683, 0x1eb, 0x11d2, 0xb1, 0xa4, 0x0, 0x40, 0x5, 0x24, 0x7c, 0x6d);
#else
DEFINE_GUID(MIGALLEY_GUID, 
0x38305683, 0x1eb, 0x11d2, 0xb1, 0xa4, 0x0, 0x40, 0x5, 0x24, 0x7c, 0x5d);
#endif 

// Callback Functions	

BOOL WINAPI	EnumConnectionsCallback(LPCGUID lpguidSP, LPVOID lpConnection, DWORD dwConnectionSize,
									LPCDPNAME lpName, DWORD dwFlags, LPVOID pContext);

BOOL WINAPI EnumSessionsCallback(LPCDPSESSIONDESC2 lpSessionDesc, LPDWORD lpdwTimeOut,
								DWORD dwFlags, LPVOID lpContext);

BOOL WINAPI EnumSessionsDataCallback(LPCDPSESSIONDESC2 lpSessionDesc, LPDWORD lpdwTimeOut,
								DWORD dwFlags, LPVOID lpContext);

//------------------------------------------------------------------------------
//Procedure		ExitDirectPlay
//Author		Andrew McRae
//Date			Fri 9 Aug 1996
//
//Description	exits DirectPlay Nice & Clean
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::ExitDirectPlay ()
{
	PlayerCreated = FALSE;
	Implemented = FALSE;
	singlesession=false;
	SideSelected=false;
	Host=FALSE;
	csync=false;												//DAW 22Jun99

	delete [] CommsPacketPtr;
	CommsPacketPtr=NULL;
	CommsPacketLength=0;

	lpAppGuid=NULL;

	if (lpDP4)
	{
		lpDP4->Close();
		lpDP4->Release();
		lpDP4=NULL;
	}

	DeleteAIACPositionsList();

	DeleteSessionList();

	DeleteServiceList();

	DeleteLobbyInfo();
}

//------------------------------------------------------------------------------
//Procedure		UIMultiPlayInit
//Author		Andy McMaster
//Date			Thu 27 Nov 1997
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool DPlay::UIMultiPlayInit ()
{
	Lobbied=FALSE;

	if (!CreateDPlayInterface())
		return FALSE;

	return TRUE;
}

//------------------------------------------------------------------------------
//Procedure		UISelectServiceProvider
//Author		Andy McMaster
//Date			Wed 9 Jul 1997
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool DPlay::UISelectServiceProvider(char* servicename)
{
	HRESULT res=DPERR_INVALIDPARAMS;
	LPENUMSERVICE temp;

	temp=ServiceList;

	while (temp)
	{
		if (!strcmp(servicename,temp->sname))
		{
			res=lpDP4->InitializeConnection(temp->connection,0);

			if (res==DP_OK)
			{
				if (temp->sid==DPSPGUID_MODEM)
				{
// special setup code for modem
					network=false;
					RateDivider=4;
					CommsTimeoutLength=20000;
					singlesession=false;
				}
				else if (temp->sid==DPSPGUID_TCPIP)
				{
// special setup code for internet

					network=false;
					RateDivider=4;
					CommsTimeoutLength=20000;
					singlesession=false;
				}
				else if (temp->sid==DPSPGUID_SERIAL)
				{
// special setup code for serial
					network=false;
					RateDivider=3;
					CommsTimeoutLength=10000;
					singlesession=true;
				}
				else if (temp->sid==DPSPGUID_IPX)
				{
// special setup code for network
					network=true;
					RateDivider=2;
					CommsTimeoutLength=10000;
					singlesession=false;
				}
				else
				{
// others - treat as internet
					network=false;
					RateDivider=4;
					CommsTimeoutLength=20000;
					singlesession=false;
				}
			}
			break;
		}
		temp=temp->Next;
	}

	if (res!=DP_OK)										
		return FALSE;

	return TRUE;
}

//------------------------------------------------------------------------------
//Procedure		UIGetSessionListUpdate
//Author		Andrew McRae
//Date			Tue 24 Sep 1996
//
//Description	Obtain and insert into list all sessions
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
bool DPlay::UIGetSessionListUpdate ()
{
	ULong n;
	char** Name;
	HRESULT res=DP_OK;												  //JIM 29/03/99
	DPSESSIONDESC2 DPSessionDesc2;

	DeleteSessionList();

	memset( &DPSessionDesc2, 0x00, sizeof(DPSESSIONDESC2));

	DPSessionDesc2.dwSize = sizeof (DPSESSIONDESC2);
 	DPSessionDesc2.guidApplication=*lpAppGuid;					

	if (lpDP4)
		res = lpDP4->EnumSessions (
			(LPDPSESSIONDESC2)&DPSessionDesc2,
			(DWORD)0,
			EnumSessionsCallback,
			(LPVOID)NULL,
			(DWORD)(DPENUMSESSIONS_AVAILABLE|DPENUMSESSIONS_ASYNC)
			);

	if (res!=DP_OK) 
	{
		return false;
	}

	return true;
}

//------------------------------------------------------------------------------
//Procedure		UIAssignServices
//Author		Andy McMaster
//Date			Fri 18 Jul 1997
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::UIAssignServices()
{
	HRESULT res;
	LPENUMSERVICE temp;
	char** Service;
	ULong size1=0,size2=0,n;

	DeleteServiceList();

	res=lpDP4->EnumConnections(lpAppGuid,EnumConnectionsCallback,NULL,0);
}

//------------------------------------------------------------------------------
//Procedure		UINewPlayer
//Author		Andrew McRae
//Date			Mon 23 Sep 1996
//
//Description	Create a new player - from enter name in UI
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool DPlay::UINewPlayer (char* Name, char* SessionName)
{
	HRESULT res;
	ULong t;
	DPSESSIONDESC2 DPSessionDesc2;

// check if name is null - if so abort
	if (!strlen(Name))
		return FALSE;

	if (ServedGame)
	{
		if (!ConnectToAggregator(aggID,Name))
			return FALSE;

		return TRUE;
	}

	if (UIPlayerType==PLAYER_HOST)
	{
// fill out dpsessiondesc2 struc

		memset(&DPSessionDesc2, 0x00, sizeof(DPSESSIONDESC2));

		DPSessionDesc2.dwSize = sizeof (DPSESSIONDESC2);
		DPSessionDesc2.dwMaxPlayers = MAXPLAYERS+1;	 // allow for aggregator
		DPSessionDesc2.guidApplication=*lpAppGuid;				
		DPSessionDesc2.dwCurrentPlayers=0;

		DPSessionDesc2.lpszSessionNameA=new char[PLAYERNAMELEN];
		strcpy( DPSessionDesc2.lpszSessionNameA, _DPlay.SessionName);
		
// create session
		DPSessionDesc2.dwFlags|=DPSESSION_DIRECTPLAYPROTOCOL	// need asyncronous send
								|DPSESSION_KEEPALIVE			// keep track of player falling out
								| DPSESSION_OPTIMIZELATENCY; // no nagling
								
		res=lpDP4->Open(&DPSessionDesc2,DPOPEN_CREATE);

		delete [] DPSessionDesc2.lpszSessionNameA;

		if (res!=DP_OK)
			return FALSE;

// myPlayerID is the Host in the session

		Host = TRUE;
		AllowJoins=TRUE;								
	}
	else if (UIPlayerType==PLAYER_GUEST)
	{
// check if session name is null - if so abort

		if (!strlen(SessionName))
			return FALSE;
	
// Connect to an existing Session

		memset( &DPSessionDesc2, 0x00, sizeof(DPSESSIONDESC2));

		DPSessionDesc2.dwSize = sizeof (DPSESSIONDESC2);

		DPSessionDesc2.guidApplication = *lpAppGuid;
		DPSessionDesc2.lpszSessionNameA=new char[PLAYERNAMELEN];
		strcpy( DPSessionDesc2.lpszSessionNameA, _DPlay.SessionName);
		
// get session data

		res = lpDP4->EnumSessions (
			(LPDPSESSIONDESC2)&DPSessionDesc2,
			(DWORD)0,
			EnumSessionsDataCallback,
			(LPVOID)SessionName,
			(DWORD)(DPENUMSESSIONS_AVAILABLE|DPENUMSESSIONS_ASYNC)
			);

		delete [] DPSessionDesc2.lpszSessionNameA;

		if (tempdpsessdesc2!=NULL)
		{
			memcpy(&DPSessionDesc2,tempdpsessdesc2,sizeof(DPSESSIONDESC2));
			delete [] tempdpsessdesc2;
			tempdpsessdesc2=NULL;
		}

		if (res!=DP_OK)
			return FALSE;

		res=lpDP4->Open ( &DPSessionDesc2,DPOPEN_JOIN );

		if (res!=DP_OK)
			return FALSE;

		Host = FALSE;

//DeadCode DAW 01Jun99 		_Replay.BackupPrefs();
	}
	else
		return FALSE;

// Create a player

	if (!SetUpPlayer())
		return FALSE;

	return TRUE;
}

//------------------------------------------------------------------------------
//Procedure		UIUpdateMainSheet
//Author		Andrew McRae
//Date			Wed 25 Sep 1996
//
//Description	Update Main Sheet with player details
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::UIUpdateMainSheet ()
{
	char* RecPacket;
	ULong RecPacketLen=0;
	ULong n,m,from;
	Bool	stop=TRUE;
	Bool	retval;

// if we are on way out then dont bother to do anything (especially process messages - ohno..)
	if (LeaveCommsFlag)
		return;

// make sure status is not 3D!									
	Implemented=FALSE;

	ResendTime--;

	if (!Host && !ResendTime)
	{
		IsGameAvailable();
		ResendTime=20;
	}

// if we are ready to go then dont receive any messages here, wait till
// selectfly !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	if (FlyNowFlag)
		return;

	for (n=0;n<MAXPLAYERS;n++)
	{
		if ((H2H_Player+n)->status==CPS_3D)
			stop=FALSE;
	}

	if (stop && !SentStopResetMess)
	{
		SentStopResetMess=TRUE;
		GameRunning=FALSE;
	}

	ULong to=myDPlayID;
	while (ReceiveNextMessage(RecPacket,RecPacketLen,from,to,DPRECEIVE_TOPLAYER))
	{
		if (from==0)
			retval=ProcessSystemMessage(RecPacket,H2H_Player[mySlot].status);
		else
		{
// if aggregated packet ignore 
			if (from!=aggID)
			{
				retval=ProcessPlayerMessage(RecPacket,RecPacketLen,from,(H2H_Player+mySlot)->status);
				if (!retval) 
					break;
			}
		}
	}

	if (!MainSheetCount) 
	{
// First time in
		InitMainSheetInfo();
		MainSheetCount=TRUE;

		for (n=0;n<MAXPLAYERS;n++)
			SyncPacks[n]=0;
	}
}

//------------------------------------------------------------------------------
//Procedure		UILeavingMainSheet
//Author		Andrew McRae
//Date			Wed 25 Sep 1996
//
//Description	Player leaves main Sheet
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::UILeavingMainSheet ()
{
	if (PlayerCreated)
	{
// Send Player leaving packet

		COMMONDATA data;

		data.PacketID=PID_PLAYERQUIT;
		data.PlayerID=myDPlayID;

		SendMessageToAll ((char*)&data,sizeof(COMMONDATA));

		MyTeamKills=0;
		MyTeamDeaths=0;
		EnemyTeamKills=0;
		EnemyTeamDeaths=0;

		if (!Host)
			_Replay.RestorePrefs();
	}
}

//------------------------------------------------------------------------------
//Procedure		UIPaintShop
//Author		Andrew McRae
//Date			Wed 25 Sep 1996
//
//Description	Toggle Paintshop flag to say if player is in Paintshop
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::UISendInPaintShopMessage ()
{
	COMMONDATA pack;

// Send PID_INPAINTSHOP
	pack.PacketID = PID_INPAINTSHOP;

	SendMessageToPlayers ((char*)&pack, sizeof(COMMONDATA));
}

//------------------------------------------------------------------------------
//Procedure		SendInVisitorsBookMessage
//Author		Andy McMaster
//Date			Mon 14 Dec 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::SendInVisitorsBookMessage()
{
	COMMONDATA pack;

	pack.PacketID = PID_INVISITORS;

	SendMessageToPlayers ((char*)&pack, sizeof(COMMONDATA));
}

//------------------------------------------------------------------------------
//Procedure		SendInDebriefMessage
//Author		Andy McMaster
//Date			Wed 16 Dec 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::SendInDebriefMessage()
{
	COMMONDATA pack;

	pack.PacketID = PID_INDEBRIEF;

	H2H_Player[mySlot].status=CPS_DEBRIEF;

	SendMessageToPlayers ((char*)&pack, sizeof(COMMONDATA));
}

//------------------------------------------------------------------------------
//Procedure		UIPrefs
//Author		Andrew McRae
//Date			Wed 25 Sep 1996
//
//Description	Toggle Prefs flag to say if player is in Prefs
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::UISendInPrefsMessage ()
{
	COMMONDATA pack;

	pack.PacketID=PID_INPREFS;

	SendMessageToPlayers ((char*)&pack, sizeof(COMMONDATA));
}

//------------------------------------------------------------------------------
//Procedure		UISendPrefs
//Author		Andrew McRae
//Date			Fri 4 Oct 1996
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool DPlay::UISendPrefs (bool request) 
{
	UIPREFSDATA UIPrefsData;

// Only send prefs if I am the host
	if (PlayerCreated && Host)
	{
		UIPrefsData.PacketID = PID_PREFSDATA;

		UIPrefsData.PlayerID = myDPlayID;

		Save_Data.gamedifficulty|=GD_VULNERABLE;
		Save_Data.gamedifficulty|=GD_GROUNDCOLLISIONS;			
		Save_Data.gamedifficulty|=GD_COLLISIONS;			
		Save_Data.flightdifficulty%=FD_AUTOTHROTTLE;			

		UIPrefsData.flightdifficulty	=	Save_Data.flightdifficulty;
		UIPrefsData.gamedifficulty		=	Save_Data.gamedifficulty;
		UIPrefsData.targetsize			=	Save_Data.targetsize;
		UIPrefsData.autopilotskillUN	= 	Save_Data.autopilotskillUN;
		UIPrefsData.autopilotskillRED	= 	Save_Data.autopilotskillRED;

		if (!request)
		{
			if (SendGMessageToPlayersTimeout ((char*)&UIPrefsData, sizeof(UIPREFSDATA)))
				return TRUE;
		}
		else
		{
			if (SendMessageToPlayers((char*)&UIPrefsData,sizeof(UIPREFSDATA)))
				return TRUE;
		}
	}
	return FALSE;
}

//------------------------------------------------------------------------------
//Procedure		UISendDialogue
//Author		Andrew McRae
//Date			Fri 27 Sep 1996
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::UISendDialogue (const char* Text)
{
	UIPLAYERDATA UIPlayerData;
	ULong UIPlayerSize;

// truncate text to 100 chars
	strncpy( &((H2H_Player+mySlot)->dialogue[0]),Text,99);
	H2H_Player[mySlot].dialogue[99]='\0';

	CopyBuffer((char*)(&UIPlayerData.playerinfo),(char*)(H2H_Player+mySlot),sizeof(H2HPlayerInfo));

// nobble playerid for use as send to all/my team switch
	UIPlayerData.PlayerID=sendtowho;
	UIPlayerData.PacketID = PID_MESSAGE;
	UIPlayerSize = sizeof (UIPLAYERDATA);

	SendMessageToPlayers ((char*)&UIPlayerData, UIPlayerSize);
}

//------------------------------------------------------------------------------
//Procedure		UINetworkSelectFly
//Author		Andrew McRae
//Date			Mon 23 Sep 1996
//
//Description	Network Fly Selection
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool DPlay::UINetworkSelectFly ()
{
	HRESULT res;
	UIPLAYERDATA UIPlayerData;
	ULong UIPlayerSize;
	char* RecPacket;
	ULong RecPacketLen,From;
	H2HPlayerInfo* thisH2H_Player;
	ULong	n;

	CountPlayers();												//DAW 27Jun99
																//DAW 27Jun99
	if (Host)													//DAW 27Jun99
	{															//DAW 27Jun99
		if (GameType>TEAMPLAY)									//DAW 27Jun99
		{														//DAW 27Jun99
			if (!AllPlayersHaveSlots())							//DAW 27Jun99
			{													//DAW 27Jun99
				CommsMessage(IDS_NOTSLOTS);						//DAW 27Jun99
				EnableJoins();									//DAW 27Jun99
				return FALSE;									//DAW 27Jun99
			}													//DAW 27Jun99
		}														//DAW 27Jun99
		else													//DAW 27Jun99
		{														//DAW 27Jun99
			for (n=0;n<MAXPLAYERS;n++)							//DAW 27Jun99
			{													//DAW 27Jun99
				if (H2H_Player[n].status!=CPS_NONE && H2H_Player[n].status!=CPS_READYROOM)//DAW 27Jun99
					return FALSE;								//DAW 27Jun99
			}													//DAW 27Jun99
		}														//DAW 27Jun99
	}															//DAW 27Jun99
// need this at beginning so that when I send my playerinfo packet the status is set up OK
// otherwise I will send a READYROOM status that may be processed after 3D status us set up
// resulting in EMPTY shapes in game

// all dudes are in 3d
	for (n=0;n<MAXPLAYERS;n++)
	{
		if (H2H_Player[n].status!=CPS_NONE)
		{
			H2H_Player[n].status=CPS_3D;
		}
	}

	if (!PlayerCreated)
	{
		return FALSE;
	}

	DisableJoins();

	AllowJoins=FALSE;
	Joining=FALSE;
	JustJoined=FALSE;
	SimulateExitKey=FALSE;
	ResetAllocPacket();

	if (GameType<COMMSCAMPAIGN)
		ClearPackages();

	if (Host)
	{
		if (!UISendFlyNow())
 		{
			EnableJoins();
			return FALSE;
		}
	}
	csync=false;

	if (!UpdateMessages())
	{
		EnableJoins();
		return FALSE;
	}

// get all players h2h_player info

	if (!UpdatePlayerInfo())
	{
		EnableJoins();
		return FALSE;
	}

// PREFS UPDATE
	if (!UIUpdatePrefs())
	{
		EnableJoins();
		return FALSE;
	}

	if (GameType<COMMSQUICKMISSION)
	{
		if (!UpdateMissionConditions())
		{
			EnableJoins();
			return FALSE;
		}
	}

	if (GameType==COMMSCAMPAIGN)
	{
		if (Host)
		{
			if (!SendSaveGame(false,false))
			{
				EnableJoins();
				return FALSE;
			}
		}
		else
		{
			if (!ReceiveStartupSaveGame(false))
			{
				EnableJoins();
				return FALSE;
			}
		}
	}
	else if (GameType==COMMSQUICKMISSION)
	{
		if (Host)
		{
			if (!SendCampaignStruc(false))
			{
				EnableJoins();
				return FALSE;
			}
		}
		else
		{
			if (!ReceiveCampaignStruc())
			{
				EnableJoins();
				return FALSE;
			}
		}
	}
	ULong	squads[SQ_R_NONFLYABLE+1];		   //include Yak
	if (GameType<COMMSQUICKMISSION)
	{
		FillCSQuickStruc();
// position 
		for (n=0;n<=SQ_R_NONFLYABLE;n++)
		{
			squads[n]=0;
		}

		for (n=0;n<MAXPLAYERS;n++)
		{
			H2H_Player[n].position=squads[H2H_Player[n].squadron];
			squads[H2H_Player[n].squadron]++;
		}
	}
	MMC.playersquadron=H2H_Player[mySlot].squadron;
	MMC.playeracnum=H2H_Player[mySlot].position;
	GR_amberstrength = MAXPLAYERS;
	InitialFlagReset();

	return TRUE;
}

//------------------------------------------------------------------------------
//Procedure		SendMessageToAll
//Author		Andrew McRae
//Date			Thu 26 Sep 1996
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool DPlay::SendMessageToAll (void* Data, ULong Length)
{
	return (SendMessage(Data,Length,DPID_ALLPLAYERS));
}

//------------------------------------------------------------------------------
//Procedure		SendMessageToPlayers
//Author		Andy McMaster
//Date			Fri 1 May 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool DPlay::SendMessageToPlayers (void* Data, ULong Length)
{
	return (SendMessage(Data,Length,playergroupID));
}

//------------------------------------------------------------------------------
//Procedure		SendMessage
//Author		Andy McMaster
//Date			Tue 25 Aug 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool DPlay::SendMessage(void* data, ULong len, ULong to)
{
	HRESULT res;
	res=lpDP4->SendEx (myDPlayID,to,DPSEND_ASYNC|DPSEND_NOSENDCOMPLETEMSG,data,len,0,0,NULL,NULL);
				
	if (res==DP_OK || res==DPERR_PENDING)
		return TRUE;

	return FALSE;
}

//------------------------------------------------------------------------------
//Procedure		SendGMessageToPlayers
//Author		Andy McMaster
//Date			Tue 16 Mar 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
bool	DPlay::SendGMessageToPlayers(char* data, ULong len)
{
	if (SendGMessageToPlayersTimeout(data,len))
		return true;

	return false;
}

//------------------------------------------------------------------------------
//Procedure		SendGMessageToPlayersTimeout
//Author		Andy McMaster
//Date			Sun 23 May 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
bool	DPlay::SendGMessageToPlayersTimeout(char* data, ULong len)
{
	HRESULT res=DPERR_SENDTOOBIG;
	ULong now=_Miles.GetSysTime();
	CommsTimeout time(now,CommsTimeoutLength);

	while (res!=DP_OK && res!=DPERR_PENDING)
	{
		now=_Miles.GetSysTime();
		if (time.TimedOut(now)) 
		{
			return false;
		}

		if (!network)
		{
			res=lpDP4->SendEx (myDPlayID,playergroupID,DPSEND_ASYNC|DPSEND_NOSENDCOMPLETEMSG,data,len,0,0,NULL,NULL);
		}
		else
		{
			res=lpDP4->SendEx (myDPlayID,playergroupID,DPSEND_GUARANTEED,data,len,0,0,NULL,NULL);
		}
	}

	return true;
}

//------------------------------------------------------------------------------
//Procedure		GetMySlot
//Author		Andy McMaster
//Date			Mon 10 Feb 1997
//
//Description	Requests host for a game id. Wait until one is received.
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool DPlay::GetMySlot()
{
	COMMONDATA pack;
	myDPID From=myDPlayID;

	pack.PlayerID=myDPlayID;
	pack.PacketID=PID_REQUESTSLOT;

// send request for id, timeout on send - session could have ended
	SendMessageToAll((char*)&pack,sizeof(COMMONDATA));

// wait for response 
	myDPID To=myDPlayID;
	From=0;
	char* Buffer;
	ULong	BufferLen=0;
	Bool	GotID=FALSE;
// NEEDTIMEOUT
	ULong now=_Miles.GetSysTime();
	CommsTimeout time(now,CommsTimeoutLength); // example!
	while(!GotID)
	{
		now=_Miles.GetSysTime();
		if (time.TimedOut(now)) // example!
			return FALSE;

		ULong to=myDPlayID;
		if (ReceiveNextMessage(Buffer,BufferLen,From,to,DPRECEIVE_TOPLAYER))
		{
			if (BufferLen==sizeof(COMMONDATA))
			{
				pack=*(PCOMMONDATA)Buffer;

				if(pack.PacketID==PID_NEWSLOT)
				{
					mySlot=pack.Slot;
					GotID=TRUE;
					aggID=From;
					playergroupID=pack.PlayerID;
				}
			}
		}
	}

// send "I'm in with this slot" message
	pack.PacketID=PID_IMHERE;
	pack.PlayerID=mySlot;
	SendMessageToAll((char*)&pack,sizeof(COMMONDATA));

	return TRUE;
}

//------------------------------------------------------------------------------
//Procedure		SendSlot
//Author		Andy McMaster
//Date			Mon 10 Feb 1997
//
//Description	Sends a packet in which game ID is for the receiving player,
//				not the id of the sender. If error occurs, I dont care,
//				player is not in game	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool DPlay::SendSlot(myDPID playerid, ULong slot)
{
	COMMONDATA	packet;
	ULong From=aggID; //,t=0;
	HRESULT res=DPERR_NOMESSAGES;

	packet.PlayerID=playergroupID;
	packet.Slot=slot;
	packet.PacketID=PID_NEWSLOT;

	res=lpDP4->SendEx(From,playerid,DPSEND_ASYNC|DPSEND_NOSENDCOMPLETEMSG,(char*)&packet,sizeof(COMMONDATA),0,0,NULL,NULL);

	if (res==DP_OK || res==DPERR_PENDING)
		return TRUE;

	return FALSE;
}

//------------------------------------------------------------------------------
//Procedure		DeleteServiceList
//Author		Andy McMaster
//Date			Mon 21 Jul 1997
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::DeleteServiceList()
{
	LPENUMSERVICE temp1,temp2;
	temp1=ServiceList;

	while (temp1)
	{
		delete[]temp1->sname;
		delete[]temp1->connection;

		temp2=temp1->Next;
		temp1->Next=NULL;

		delete temp1;

		temp1=temp2;
	}
	ServiceList=NULL;
}

//------------------------------------------------------------------------------
//Procedure		CreateDPlayInterface
//Author		Andy McMaster
//Date			Wed 26 Nov 1997
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::CreateDPlayInterface()
{
	HRESULT res;

	res = CoCreateInstance( CLSID_DirectPlay, NULL, CLSCTX_INPROC_SERVER, 
		IID_IDirectPlay4A, (LPVOID*)&lpDP4);
	
	lpAppGuid=(LPGUID)&MIGALLEY_GUID;						//AMM 23Sep97

	if (res!=DP_OK)
		return FALSE;

	return TRUE;
}

//------------------------------------------------------------------------------
//Procedure		CountPlayers
//Author		Andy McMaster
//Date			Wed 10 Dec 1997
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::CountPlayers()
{
	CurrPlayers=0;

	for (ULong n=0;n<MAXPLAYERS;n++)
	{
		if (H2H_Player[n].status!=CPS_NONE)
			CurrPlayers++;
	}
}

//------------------------------------------------------------------------------
//Procedure		EnumConnectionsCallback
//Author		Andy McMaster
//Date			Wed 26 Nov 1997
//
//Description	Gets list of service providers and put them
//				into ServiceList
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
BOOL WINAPI	EnumConnectionsCallback(LPCGUID lpguidSP,
									LPVOID lpConnection,
									DWORD dwConnectionSize,
									LPCDPNAME lpName,
									DWORD dwFlags,
									LPVOID pContext)
{
	ULong namelen;
	LPENUMSERVICE temp=_DPlay.ServiceList;

	if (lpguidSP)
	{
		LPENUMSERVICE nextservice=new ENUMSERVICE;

		nextservice->Next=NULL;

		nextservice->sid=*lpguidSP;

		namelen=strlen(lpName->lpszShortNameA);
		nextservice->sname=new char[namelen+1];

		strcpy(nextservice->sname,lpName->lpszShortNameA);

		nextservice->connsize=dwConnectionSize;
		nextservice->connection=new UByte[dwConnectionSize];

		memcpy(nextservice->connection,lpConnection,dwConnectionSize);

		if (_DPlay.ServiceList==NULL)
		{
			_DPlay.ServiceList=nextservice;
		}
		else
		{
			while (temp->Next)
				temp=temp->Next;

			temp->Next=nextservice;
		}

		nextservice=NULL;
	}

	return TRUE;
}

//------------------------------------------------------------------------------
//Procedure		EnumSessionsCallback
//Author		Andy McMaster
//Date			Wed 26 Nov 1997
//
//Description	Get list of session names for player to choose from
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
BOOL WINAPI EnumSessionsCallback(LPCDPSESSIONDESC2 lpSessionDesc,
								LPDWORD lpdwTimeOut,
								DWORD dwFlags,
								LPVOID lpContext)
{
	ULong namelen;
	LPENUMSESSION temp=_DPlay.SessionList;

	if (lpSessionDesc)
	{
		LPENUMSESSION newsess=new ENUMSESSION;

		newsess->Next=NULL;
		namelen=strlen(lpSessionDesc->lpszSessionNameA);
		newsess->sname=new char[namelen+1];

		strcpy(newsess->sname,lpSessionDesc->lpszSessionNameA);

		if (_DPlay.SessionList==NULL)
		{
			_DPlay.SessionList=newsess;
		}
		else
		{
			while (temp->Next)
				temp=temp->Next;

			temp->Next=newsess;
		}

		newsess=NULL;

		return TRUE;
	}
	return FALSE;
}

//------------------------------------------------------------------------------
//Procedure		EnumSessionsDataCallback
//Author		Andy McMaster
//Date			Wed 26 Nov 1997
//
//Description	Get data of session chosen by player and copy into dpsessiondesc2
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
BOOL WINAPI EnumSessionsDataCallback(LPCDPSESSIONDESC2 lpSessionDesc,
								LPDWORD lpdwTimeOut,
								DWORD dwFlags,
								LPVOID lpContext)
{
	if (lpSessionDesc)
	{
		if (!strcmp((char*)lpContext, lpSessionDesc->lpszSessionNameA))
		{
			_DPlay.tempdpsessdesc2=new char[sizeof(DPSESSIONDESC2)];
			memcpy(_DPlay.tempdpsessdesc2,lpSessionDesc,sizeof(DPSESSIONDESC2));

			return FALSE;
		}
		return TRUE;
	}
	return FALSE;
}

//------------------------------------------------------------------------------
//Procedure		CopyBuffer
//Author		Andy McMaster
//Date			Wed 10 Dec 1997
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::CopyBuffer(char* dest, char* src, ULong size)
{
	memcpy (dest,src,size);
}

//------------------------------------------------------------------------------
//Procedure		ProcessSystemMessage
//Author		Andy McMaster
//Date			Wed 10 Dec 1997
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::ProcessSystemMessage(char* message, UByte ctrl) //,ULong size)
{
	LPDPMSG_GENERIC Mess,Mess2;
	ULong n;
	
	Mess=(LPDPMSG_GENERIC)message;

	switch (Mess->dwType)
	{
		case DPSYS_ADDGROUPTOGROUP:
			LPDPMSG_ADDGROUPTOGROUP Mess2;

			Mess2=(LPDPMSG_ADDGROUPTOGROUP)message;
			break;

		case DPSYS_ADDPLAYERTOGROUP:
			LPDPMSG_ADDPLAYERTOGROUP Mess3;

			Mess3=(LPDPMSG_ADDPLAYERTOGROUP)message;

			lpDP4->AddPlayerToGroup(Mess3->dpIdGroup,Mess3->dpIdPlayer);
			break;

		case DPSYS_CHAT:
			LPDPMSG_CHAT Mess4;

			Mess4=(LPDPMSG_CHAT)message;
			break;

		case DPSYS_CREATEPLAYERORGROUP:
			LPDPMSG_CREATEPLAYERORGROUP Mess5;

			Mess5=(LPDPMSG_CREATEPLAYERORGROUP)message;
			break;

		case DPSYS_DELETEGROUPFROMGROUP:
			LPDPMSG_DELETEGROUPFROMGROUP Mess6;

			Mess6=(LPDPMSG_DELETEGROUPFROMGROUP)message;
			break;

		case DPSYS_DELETEPLAYERFROMGROUP:
			LPDPMSG_DELETEPLAYERFROMGROUP Mess7;

			Mess7=(LPDPMSG_DELETEPLAYERFROMGROUP)message;

			lpDP4->DeletePlayerFromGroup(Mess7->dpIdGroup,Mess7->dpIdPlayer);

			break;

		case DPSYS_DESTROYPLAYERORGROUP:
			LPDPMSG_DESTROYPLAYERORGROUP Mess8;

			Mess8=(LPDPMSG_DESTROYPLAYERORGROUP)message;

			if (Mess8->dwPlayerType==DPPLAYERTYPE_PLAYER)
			{
				for (n=0;n<MAXPLAYERS;n++)
				{
					if (Mess8->dpId==H2H_Player[n].dpid)
						break;
				}

				if (n==MAXPLAYERS)
					break;

// remove player from 3D if in 3D, and then from game
				bool	wasin3d=false;
				ULong	slot=DPID2Slot(Mess8->dpId);

				if (slot<MAXPLAYERS)
				{
					if (H2H_Player[slot].status==CPS_3D)
						wasin3d=true;
				}
				
				ProcessPlayerGone(Mess8->dpId,TRUE); 
				ProcessPlayerGone(Mess8->dpId,FALSE); 

				if (ctrl==CPS_READYROOM)
					DisplayInfo=TRUE;

				if (Mess8->dpId==H2H_Player[0].dpid)
				{
// host has gone - lets go as well
					LeaveCommsFlag=TRUE;
					HostQuitFlag=TRUE;
				}
				else if (Host && ResyncPhase && wasin3d)
				{
// if player has left game whilst in sync phase then host restarts sync
					Initiator=TRUE;
					BeginSyncPhase();
				}
			}
			break;

		case DPSYS_HOST:
			LPDPMSG_HOST Mess9;

			Mess9=(LPDPMSG_HOST)message;

			LeaveCommsFlag=TRUE;
			HostQuitFlag=TRUE;

			break;

		case DPSYS_SECUREMESSAGE:
			LPDPMSG_SECUREMESSAGE Mess10;

			Mess10=(LPDPMSG_SECUREMESSAGE)message;
			break;

		case DPSYS_SESSIONLOST:
			LPDPMSG_SESSIONLOST Mess11;

			Mess11=(LPDPMSG_SESSIONLOST)message;

			LeaveCommsFlag=TRUE;

			break;

		case DPSYS_SETPLAYERORGROUPDATA:
			LPDPMSG_SETPLAYERORGROUPDATA Mess12;

			Mess12=(LPDPMSG_SETPLAYERORGROUPDATA)message;
			break;

		case DPSYS_SETPLAYERORGROUPNAME:
			LPDPMSG_SETPLAYERORGROUPNAME Mess13;

			Mess13=(LPDPMSG_SETPLAYERORGROUPNAME)message;
			break;

		case DPSYS_SETSESSIONDESC:
			LPDPMSG_SETSESSIONDESC Mess14;

			Mess14=(LPDPMSG_SETSESSIONDESC)message;
			break;

		case DPSYS_STARTSESSION:
			LPDPMSG_STARTSESSION Mess15;

			Mess15=(LPDPMSG_STARTSESSION)message;
			break;

		case DPSYS_SENDCOMPLETE:
			LPDPMSG_SENDCOMPLETE Mess16;

			Mess16=(LPDPMSG_SENDCOMPLETE)message;

// dont care about complete sends, I dont care if messages are sent or not!!!!
// anyway these messages should not arrive as I turn them off.....
			break;

		case DPSYS_SETGROUPOWNER:
			LPDPMSG_SETGROUPOWNER Mess17;

			Mess17=(LPDPMSG_SETGROUPOWNER)message;
			break;

		default:
// some future version of direct play may use other messages so dont error
			break;
	}

	return TRUE;
}

//------------------------------------------------------------------------------
//Procedure		ProcessPlayerMessage
//Author		Andy McMaster
//Date			Wed 10 Dec 1997
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::ProcessPlayerMessage(char* message,ULong size,ULong from,UByte ctrl)
{
	Bool	retval=TRUE;
	PUIPLAYERDATA pUIPlayerData = (PUIPLAYERDATA)message;
	UIPLAYERDATA UIPlayerData;
	PGAMEAVAILABLEPACKET gap;
	LPPASSWORDPACK ppack;
	PINITINFO ipack;
	ULong n;
 	UILOOKUPTABLE ltable;
	SLong senders_slot=-1;
	UByteP temp;

	for (n=0;n<MAXPLAYERS;n++)
	{
		if (H2H_Player[n].dpid==from)
		{
			senders_slot=n;
			break;
		}
	}

	switch (pUIPlayerData->PacketID)
	{
		case PID_CSSTRUC:
			Process_PM_CSStruc(message);
			break;
			
		case PID_AAAPACKET:
			break;

		case PID_RANDOMLIST:
			ProcessRandomList(message);
			break;

		case PID_RANDREQUEST:
			if (Host)
			{
				SendBackupRandomList(true);
			}
			break;

		case PID_QUITACCEL:
			if (H2H_Player[mySlot].status==CPS_3D)
			{
				ProcessQuitAccelMessage(senders_slot);
			}
			break;
		case PID_CAMPAIGNSTRUC:
			break;

		case PID_SINGLEPILOTSTATUS:
			ProcessPilotStatusPacket(true,(UByteP)message);
			break;
		case PID_ALLPILOTSSTATUS:
			ProcessPilotStatusPacket(false,(UByteP)message);
			ApplyBackupPilots();
			break;

		case PID_NUMDEADBLOCKS:
			break;
		case PID_DEADBLOCKDATA:
			break;

		case PID_RESTARTWORLDSYNC:
			RestartWorldSync=true;
			break;

		case PID_NEWPLAYER:
		case PID_PLAYERUPDATE:

			CopyBuffer((char*)&H2H_Player[pUIPlayerData->Slot],(char*)&pUIPlayerData->playerinfo,sizeof(H2HPlayerInfo));

// display data
			if (ctrl==CPS_READYROOM)
				DisplayInfo=TRUE;

			break;

		case PID_IMHERE:

			for (n=0;n<MAXPLAYERS;n++)
			{
				if (n==pUIPlayerData->PlayerID)
				{
					H2H_Player[n].dpid=from;
					H2H_Player[n].status=CPS_READYROOM;
				}
			}

			break;

		case PID_PLAYERQUIT:

			if (senders_slot==0)
			{
// Host quit - chuck all players back to intro screen
				MyTeamKills=0;
				MyTeamDeaths=0;
				EnemyTeamKills=0;
				EnemyTeamDeaths=0;
				retval=FALSE;
				SimulateExitKey=TRUE; 
				LeaveCommsFlag=TRUE;
				break;
			}
			else
			{
				ProcessPlayerGone(from,FALSE);

				if (ctrl==CPS_READYROOM)
					DisplayInfo=TRUE;
				UpdateFrag=TRUE; // get rid of player from frag screen
			}
			break;

		case PID_MESSAGE:
			if (pUIPlayerData->PlayerID==255
			|| (pUIPlayerData->PlayerID==128 && pUIPlayerData->playerinfo.MyTeam==H2H_Player[mySlot].MyTeam)
			|| (pUIPlayerData->PlayerID==mySlot))
			{
				if (ctrl==CPS_READYROOM)
					DisplayReadyDialogue(pUIPlayerData->playerinfo.name,pUIPlayerData->playerinfo.dialogue);
#ifndef	MIG_DEMO_VER
				else if (ctrl==CPS_FRAG)
					DisplayFragDialogue(pUIPlayerData->playerinfo.name,pUIPlayerData->playerinfo.dialogue);
#endif
			}
			AddChatMessageToBuffer(pUIPlayerData->playerinfo.name,pUIPlayerData->playerinfo.dialogue);
			break;

		case PID_REQUESTSLOT:
			if(Host && AllowJoins)
			{
				SLong nextslot=GetNextAvailableSlot();

				if (nextslot>=0)
				{
					if (SendSlot(from,nextslot))
					{
						H2H_Player[nextslot].dpid=from;
						H2H_Player[nextslot].status=CPS_JOINING;
					}
				}
			}
			break;

		case PID_DATAREQUEST:
// this is called firsttime in to get players info
// Send PID_PLAYERUPDATE - copy info in packet h2hplayer
			SendMyPlayerInfo(true);

			if (Host)
			{
				UISendPrefs (true);
				if (GameType==COMMSQUICKMISSION)
				{
// send as an init packet so that players currently in do not get positions reset
					SendCSQuickStrucToPlayers(TRUE);
				}
			}
			break;

		case PID_INPAINTSHOP:
			if (senders_slot!=-1)
				H2H_Player[senders_slot].status = CPS_PAINTSHOP;

			DisplayInfo=TRUE;
			break;

		case PID_INPREFS:
			if (senders_slot!=-1)
				H2H_Player[senders_slot].status = CPS_PREFS;

			DisplayInfo=TRUE;
			break;
		 
		case PID_INFRAG:
			if (senders_slot!=-1)
				H2H_Player[senders_slot].status = CPS_FRAG;

			DisplayInfo=TRUE;
			break;
		 
		case PID_INMAP:
			if (senders_slot!=-1)
				H2H_Player[senders_slot].status = CPS_MAP;

			DisplayInfo=TRUE;
			break;
		 
		case PID_INMISSIONBRIEF:
			if (senders_slot!=-1)
				H2H_Player[senders_slot].status = CPS_MISSIONBRIEF;

			DisplayInfo=TRUE;
			break;
		 
		case PID_INRADIO:
			if (senders_slot!=-1)
				H2H_Player[senders_slot].status = CPS_RADIO;

			DisplayInfo=TRUE;
			break;
		 
		case PID_INREADYROOM:
			if (senders_slot!=-1)
				H2H_Player[senders_slot].status = CPS_READYROOM;

			DisplayInfo=TRUE;
			break;
		 
		case PID_INVISITORS:
			if (senders_slot!=-1)
				H2H_Player[senders_slot].status = CPS_VISITORBOOK;

			DisplayInfo=TRUE;
			break;

		case PID_INDEBRIEF:
			if (senders_slot!=-1)
				H2H_Player[senders_slot].status=CPS_DEBRIEF;

			DisplayInfo=TRUE;
			break;
		 
		case PID_PREFSDATA:
			if (H2H_Player[mySlot].status!=CPS_3D)
			{
				ProcessPrefsPacket(message);
			}
			break;

		case PID_FLYNOW:
			if (!Host && (H2H_Player[mySlot].status==CPS_READYROOM || H2H_Player[mySlot].status==CPS_FRAG))
			{
				FlyNowFlag = TRUE;
				return FALSE;
			}
			break;

		case PID_PLAYERLEAVINGGAME:
			if (senders_slot!=-1)
				H2H_Player[senders_slot].status=CPS_READYROOM;
			break;

		case PID_IAMIN:
			if (H2H_Player[mySlot].status==CPS_3D)
			{
				ULong slot;
				LPALLOCREQUEST arpack=(LPALLOCREQUEST)pUIPlayerData;
				
				slot=arpack->Slot;
				H2H_Player[slot].status=CPS_3D;
				AddPlayerToGame(slot,arpack->PlayerID,arpack->id);
				DisplayPlayerJoiningMessage(senders_slot);
			}
			else
			{
				if (senders_slot!=-1)
					H2H_Player[senders_slot].status=CPS_3D;
			}
			break;

		case PID_GAMEAVAILABLE:
			gap=(PGAMEAVAILABLEPACKET)pUIPlayerData;
			GameAvailable=gap->available;
			break;

		case PID_PASSWORD:
			if (Host)
			{
				ppack=(LPPASSWORDPACK)message;

				CheckPassword(ppack->pword,ppack->name,from);
			}
			break;

		case PID_VISITORUPDATE:
			if (Host)
			{
				ipack=(PINITINFO)message;
				AddNameToVisitorsBook(ipack->Name);
			}
			break;

		case PID_SYNC:
			for (n=0;n<MAXPLAYERS;n++)
			{
				if (H2H_Player[n].dpid==from)
				{
					SyncPacks[n]++;

					if (!(SyncBits & (1<<n)))
					{
						SyncBits |= (1 << n);
						SyncPacks[n]--;
					}
					break;
				}
			}
			break;

		case PID_NEEDRESYNC:
			if (H2H_Player[mySlot].status==CPS_3D && !Joining)
			{
				if (!ResyncPhase)
				{ 
					BeginSyncPhase();
					return FALSE;
				}
			}
			break;

		case PID_ISTHEREAGAME:
			if (Host)
			{
// only game in progress if host is in 3d and flying along nicely
				if (H2H_Player[mySlot].status==CPS_3D) 
				{
	   				SendGameAvailableMessage(TRUE);
				}
				else
				{
	   				SendGameAvailableMessage(FALSE);
				}
			}
			break;

		case PID_PREFSREQUEST:
			if (Host)
			{
				if (!UISendPrefs(true))
					_Error.SayAndQuit("Error sending prefs");
			}
			break;

		case PID_ALLOCREQUEST:
			if (Host)
			{
				for (n=0;n<MAXPLAYERS;n++)
				{
					if (H2H_Player[n].dpid==from)
						AllocPacket[n]=((LPALLOCREQUEST)message)->id;
				}
				ltable.PacketID=PID_ALLOCPACKET;
				ltable.PlayerID=myDPlayID;

				for (n=0;n<MAXPLAYERS;n++)
				{
					ltable.Table[n]=AllocPacket[n];
				}

				SendMessageToPlayers((char*)&ltable,sizeof(UILOOKUPTABLE));
			}
			break;

		case PID_BFIELDREQUEST:
			if (Host)
			{
				SendBFieldsToPlayers(true);
			}
			break;

		case PID_SLOTREQUEST:
			if (Host && AllowJoins)
			{
				ProcessPlayerSlotRequest(message,from,ctrl);
			}
			break;

		case PID_SLOTINFOUPDATE:
			ProcessSlotInfoUpdate(message);
			break;

		case PID_GAMEDETAILSREQUEST:
			if (Host)
				SendGameDetails();
			break;

		case PID_PLAYERINFOREQUEST:
			SendMyPlayerInfo(true);
			break;

		case PID_CSQUICKREQUEST:
			if (Host)
			{
				if (GameType!=COMMSCAMPAIGN)					//DAW 22Jun99
					SendCSQuickStrucToPlayers(TRUE);

				if (GameType>TEAMPLAY)
					SendPilotsStatus(false);

				if (GameType==COMMSCAMPAIGN)
					SendSaveGame(false,true);
				else if (GameType==COMMSQUICKMISSION)
					SendCampaignStruc(true);
			}
			break;

		case PID_MISSCONDSREQUEST:
			if (Host)
				SendMissionConditions(true);
			break;

		case PID_MESSAGES:
			ReceiveMessages((UByte*)message,from);
			break;

		case PID_MESSAGESREQUEST:
			SendMyMessages(true);
			break;

		case PID_SAVEGAME:
			if (!Host && H2H_Player[mySlot].status!=CPS_3D)
 				ReceiveSaveGame(false,((PCOMMONDATA)message)->PlayerID,((PCOMMONDATA)message)->Slot);

			if (H2H_Player[mySlot].status==CPS_FRAG)	//AMM 07/06/99
					FragChanged=true;					//AMM 07/06/99
			break;

		case PID_GAMEDETAILSINFO:
// i'm already in game so I already have game details!
			break;
		case PID_RESYNC:
			if (H2H_Player[mySlot].status==CPS_3D) //AMM 17/05/99
				ProcessResyncPacket((LPACSTATEPACKET)message,senders_slot);
			break;

// should get processed elsewhere
		case PID_NEWSLOT:
// not for me, i already know my slot!
		case PID_ALLOCPACKET:
// picked up elsewhere
		case PID_PASSWORDVALID:
// hey, I'm already in session I know password....
		case PID_HOSTBUSY:
// so what, only interested if im joining
			break;

		case PID_ACDATA:
		case PID_MOBDATA:
		case PID_ITEMDATA:
		case PID_NUMACANIMS:
		case PID_NUMMOBANIMS:
		case PID_NUMITEMANIMS:
		case PID_ACANIM:
		case PID_MOBANIM:
		case PID_ITEMANIM:
		case PID_GOTWORLD:
//player may be joining, still ignore these packets though
			break;

		case PID_BFIELDPACKETIDENT:
			break;

		case PID_READYWORLD:
			SyncData.wsrgot+=1<<DPID2Slot(from);
			break;

		case PID_SAVEGAMEBINARY:
			break;

		case PID_HOSTLEAVING:
			SimulateExitKey=TRUE;
			HostQuit=true;
			break;

		case PID_GUESTLEAVING:
			ProcessGuestLeavingMessage(from);
			break;

		default:
#ifndef NDEBUG
			if (size==sizeof(ACPACKET))
				INT3;
#endif
			break;
	}

	return retval;
}

//------------------------------------------------------------------------------
//Procedure		SendFlyNow
//Author		Andy McMaster
//Date			Mon 15 Dec 1997
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::UISendFlyNow()
{
	UIPLAYERDATA UIPlayerData;

	UIPlayerData.PlayerID = myDPlayID;
	UIPlayerData.Slot = mySlot;
	UIPlayerData.PacketID = PID_FLYNOW;
	
	if (!SendMessageToPlayers ((char*)&UIPlayerData, sizeof(UIPLAYERDATA)))
	{
		return FALSE;
	}
	return TRUE;
}

//------------------------------------------------------------------------------
//Procedure		UIUpdatePrefs
//Author		Andy McMaster
//Date			Mon 15 Dec 1997
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::UIUpdatePrefs()
{
	ULong RecPacketLen;
	ULong from;
	char* RecPacket;

// NEEDTIMEOUT
	if (Host)
	{
		if (!UISendPrefs (false))
		{
			return FALSE;
		}
	}
	else
	{ // Guest
// Receive Prefs Packet
		ULong now=_Miles.GetSysTime();;

		CommsTimeout time(now,CommsTimeoutLength);

		for (;;)
		{
			now=_Miles.GetSysTime();

			if (time.TimedOut(now))
			{
				return FALSE;
			}

			ULong to=myDPlayID;
			if (ReceiveNextMessage(RecPacket, RecPacketLen,from,to,DPRECEIVE_TOPLAYER))
			{
				if (from==0)
				{
					ProcessSystemMessage(RecPacket,RecPacketLen);
				}
				else if (from!=aggID)
				{
					PUIPLAYERDATA pUIPlayerData = (PUIPLAYERDATA)RecPacket;

					if (pUIPlayerData->PacketID == PID_PREFSDATA)
				   	{
						ProcessPrefsPacket(RecPacket);
						break;

					}
					else
					{
						ProcessPlayerMessage(RecPacket,RecPacketLen,from,CPS_GAMESTARTUP);
					}
				}
			}
		}
	}
	return TRUE;
}

//------------------------------------------------------------------------------
//Procedure		InitMainSheetInfo
//Author		Andy McMaster
//Date			Thu 18 Dec 1997
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::InitMainSheetInfo()
{
	UIPLAYERDATA UIPlayerData;

// Signal this player is not in 3D
	(H2H_Player + mySlot)->status = CPS_READYROOM; // ready
	_DPlay.UpdateChatBox();

// Send PID_NEWPLAYER
	CopyBuffer((char*)(&UIPlayerData.playerinfo),(char*)(H2H_Player+mySlot),sizeof(H2HPlayerInfo));

	UIPlayerData.PlayerID = myDPlayID;
	UIPlayerData.Slot=mySlot;

	UIPlayerData.PacketID = PID_NEWPLAYER;

	SendMessageToPlayers ((char*)&UIPlayerData, sizeof(UIPLAYERDATA));

// Send DATA REQUEST for other players
	UIPlayerData.PlayerID = myDPlayID;
	UIPlayerData.Slot=mySlot;
	UIPlayerData.PacketID = PID_DATAREQUEST;

	SendMessageToPlayers ((char*)&UIPlayerData, sizeof(UIPLAYERDATA));

	if (Host)
		UISendPrefs (true);

	DisplayInfo=TRUE;
}

//------------------------------------------------------------------------------
//Procedure		ConnectToAggregator
//Author		Andy McMaster
//Date			Mon 9 Feb 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::ConnectToAggregator(ULong& aggregatorID,char* Name)
{
	HRESULT res;
	DPSESSIONDESC2 DPSessionDesc2;

	char*	SessionName=new char[20];

	strcpy (SessionName,"Aggregator");

// Connect to an existing Session
	memset( &DPSessionDesc2, 0x00, sizeof(DPSESSIONDESC2));

	DPSessionDesc2.dwSize = sizeof (DPSESSIONDESC2);

	DPSessionDesc2.guidApplication = *lpAppGuid;
	DPSessionDesc2.lpszSessionNameA=new char[PLAYERNAMELEN];
	strcpy( DPSessionDesc2.lpszSessionNameA, SessionName);

// get session data
	res = lpDP4->EnumSessions (
		(LPDPSESSIONDESC2)&DPSessionDesc2,
		(DWORD)0,
		EnumSessionsDataCallback,
		(LPVOID)SessionName,
		(DWORD)(DPENUMSESSIONS_AVAILABLE|DPENUMSESSIONS_ASYNC)
		);

	if (res!=DP_OK)
		return FALSE;

	res=lpDP4->Open ( &DPSessionDesc2,DPOPEN_JOIN );

	if (res!=DP_OK)
		return FALSE;

	if (lpDP4->CreatePlayer ( &myDPlayID, NULL, NULL, NULL,0,0) != DP_OK)
		return FALSE;

	if (!GetMySlot())
		return FALSE;

	if (mySlot==1)
	{
		Host=TRUE;
	}
	else
		Host=FALSE;

// Init H2H_Player List
	InitH2HPArray();

// fill in name ,initial null dialogue, 0 kills and deaths 
	strcpy ((H2H_Player + mySlot)->name, PlayerName);
	(H2H_Player + mySlot)->status = CPS_READYROOM;
	strcpy ((H2H_Player + mySlot)->dialogue, "");

	PlayerCreated = TRUE;
	FlyNowFlag = FALSE;

	return TRUE;
}

//------------------------------------------------------------------------------
//Procedure		StartCommsSession
//Author		Andy McMaster
//Date			Thu 11 Jun 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::StartCommsSession()
{
	if (!UIMultiPlayInit())
		return FALSE;

	UIAssignServices();

	return TRUE;
}

Bool	DPlay::LaunchedByLobbyCheck()
{
	HRESULT res;
	DWORD	size=0;

	CommsTimeoutLength=30000;
	network=false;
	RateDivider=5;

	res=CoCreateInstance(CLSID_DirectPlayLobby,NULL,CLSCTX_INPROC_SERVER,
		IID_IDirectPlayLobby3A,(LPVOID*)&lpDPL);

	if (res!=DP_OK)
	{
		ExitDirectPlay();
		return FALSE;
	}

	res=lpDPL->GetConnectionSettings(0,NULL,&size);

	if (res!=DP_OK && res!=DPERR_BUFFERTOOSMALL)
	{
		ExitDirectPlay();
		return FALSE;
	}

	templpDPC=(new char[size]);

	LPDPLCONNECTION lpDPC=(LPDPLCONNECTION)templpDPC;

	if (lpDPL->GetConnectionSettings(0,lpDPC,&size)!=DP_OK)
	{
		lpDPC=NULL;
		ExitDirectPlay();
		return FALSE;
	}

// set up session flags
	lpDPC->lpSessionDesc->dwFlags=DPSESSION_DIRECTPLAYPROTOCOL	// need asyncronous send
								|DPSESSION_KEEPALIVE			// keep track of player falling out
								| DPSESSION_OPTIMIZELATENCY; // no nagling

	lpDPC->lpSessionDesc->dwMaxPlayers=MAXPLAYERS+1;

	res=lpDPL->SetConnectionSettings(0,0,lpDPC);

	if (res!=DP_OK)
	{
		lpDPC=NULL;
		ExitDirectPlay();
		return FALSE;
	}

	lpDPC=NULL;
	PossibleLobby=true;

	_Replay.Record=FALSE;
	_Replay.Playback=FALSE;
	_Replay.BackupPrefs();										
 	Save_Data.gamedifficulty|=GD_VULNERABLE;
 	Save_Data.gamedifficulty|=GD_GROUNDCOLLISIONS;			
 	Save_Data.gamedifficulty|=GD_COLLISIONS;			
	Save_Data.flightdifficulty%=FD_AUTOTHROTTLE;

	return TRUE;
}

Bool DPlay::ConnectToLobby()
{
	HRESULT res;

// if I am a guest then try to connect to the session
// host must wait until he has set up game options
	if (!PossibleLobby)
		return FALSE;

	LPDPLCONNECTION lpDPC=(LPDPLCONNECTION)templpDPC;

	if (!(lpDPC->dwFlags&DPLCONNECTION_CREATESESSION))
	{
		if (false)
		{
			if (lpDPL->ConnectEx(0,IID_IDirectPlay4A,(void**)&lpDP4,NULL)!=DP_OK)
			{
				lpDPC=NULL;
				ExitDirectPlay();
				return FALSE;
			}
		}
		else
		{
			ULong now=_Miles.GetSysTime();
// default timeout for ConnectEx is 60secs
			res=DPERR_CONNECTING;
			res=lpDPL->ConnectEx(DPCONNECT_RETURNSTATUS,IID_IDirectPlay4A,(void**)&lpDP4,NULL);
			if (res!=DP_OK)
			{
				lpDPC=NULL;
				return FALSE;
			}
		}
	}

	lpDPC=NULL;
	return TRUE;
}

Bool DPlay::FinishLobbySetup()
{
	LPDPLCONNECTION lpDPC=(LPDPLCONNECTION)templpDPC;

	lpAppGuid=(LPGUID)&MIGALLEY_GUID;					

	if (lpDPC->dwFlags&DPLCONNECTION_CREATESESSION)
	{
		UIPlayerType=PLAYER_HOST;
		Host=TRUE;
		AllowJoins=TRUE;
	}
	else
	{
		UIPlayerType=PLAYER_GUEST;
		Host=FALSE;
	}

	if (lpDPC->lpPlayerName->lpszShortNameA)
	{
		//RERUN strncpy (PlayerName,(char*)lpDPC->lpPlayerName->lpszShortNameA,59);
		//PlayerName[59]=NULL;
		strncpy(PlayerName, (char*)lpDPC->lpPlayerName->lpszShortNameA, 21); //RERUN playername field is 21 chars
		PlayerName[20] = NULL; //RERUN playername field is 21 chars
	}
	else
	{
		strcpy(PlayerName,"Unnamed Player");
	}

	if (lpDPC->lpSessionDesc->lpszSessionNameA)
	{
		strncpy (SessionName,(char*)lpDPC->lpSessionDesc->lpszSessionName,59);
		SessionName[59]=NULL;
	}
	else
	{
		strcpy(SessionName,"Lobbied Game");
	}

	if (!Host)
	{
		if (!SetUpPlayer())
		{
			lpDPC=NULL;
			ExitDirectPlay();
			return FALSE;
		}
		if (UIPlayerType==PLAYER_GUEST)
		{
			if (!_DPlay.GetGameDetails())
			{
				lpDPC=NULL;
				CommsMessage(IDS_HOSTBUSY);
				ExitDirectPlay();
				return FALSE;
			}
		}
	}

	lpDPC=NULL;
	Lobbied=TRUE;

	return TRUE;
}

//------------------------------------------------------------------------------
//Procedure		SetUpPlayerInfo
//Author		Andy McMaster
//Date			Fri 12 Jun 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::SetUpPlayerInfo(char* name)
{
// determine capabilities
	DPCAPS dpCaps;
	dpCaps.dwSize=sizeof(DPCAPS);

	if (lpDP4->GetCaps(&dpCaps,0)!=DP_OK)
		return FALSE;

	if(!Host)
	{
		if (!GetMySlot())
			return FALSE;
	}
	else
	{
		mySlot=0;
	}

	if (lpDP4->AddPlayerToGroup(playergroupID,myDPlayID) != 0)
		return FALSE;

	InitH2HPArray();

// fill in name ,initial null dialogue, 0 kills and deaths 
	(H2H_Player+mySlot)->dpid=myDPlayID;

// if there is no name use a default
	if (!strcmp(name,""))
		strcpy ((H2H_Player + mySlot)->name, "Unnamed Player");
	else
		strcpy ((H2H_Player + mySlot)->name, name);

	(H2H_Player + mySlot)->status = CPS_READYROOM;
	strcpy ((H2H_Player + mySlot)->dialogue, "");

	if (_DPlay.GameType!=DEATHMATCH)
	{
		if (Side)
			(H2H_Player+mySlot)->MyTeam=TS_UN;
		else
			(H2H_Player+mySlot)->MyTeam=TS_COMMIE;
	}
	else
	{
		(H2H_Player+mySlot)->MyTeam=TSIDE_NONE;
	}

	FlyNowFlag = FALSE;
	sendtowho=255; // initially chat to everybody

// need to set up default AC for deathmatch/teamplay
	if (GameType==DEATHMATCH)
	{
		H2H_Player[mySlot].squadron=0;
	}
	else if (GameType==TEAMPLAY)
	{
		if (Side)
		{
			H2H_Player[mySlot].squadron=0;
		}
		else
		{
			H2H_Player[mySlot].squadron=SQ_R_FLYABLE;
		}
	}

	ChatBuffer.InitBuffer();

	return TRUE;
}

//------------------------------------------------------------------------------
//Procedure		AddNameToVisitorsBook
//Author		Andy McMaster
//Date			Fri 12 Jun 1998
//
//Description	Only Host can add and remove name from the visitors book.
//				All other players must use SendUpdateToVisitorsBook to
//				alter it.
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::AddNameToVisitorsBook(char* name)
{
	if (Host && Password[0])
	{
		if (VisitorsBook)
		{
			LPVISITORINFO temp=VisitorsBook;

			while (temp)
			{
				if (!strcmp(temp->vis_name,name))
					return;

				temp=temp->next;
			}

			temp=VisitorsBook;

			while (temp->next)
			{
				temp=temp->next;
			}

			LPVISITORINFO a=new VISITORINFO;

			a->vis_status=FALSE;
			a->vis_name=new char[strlen(name)+1];
			strcpy(a->vis_name,name);
			a->next=NULL;
			temp->next=a;
			a=NULL;

			char temptext[256];
			strcpy(&temptext[0],name);
			strcat(&temptext[0]," has added name to visitor book");

			if ((H2H_Player+mySlot)->status==CPS_READYROOM)
				DisplayReadyDialogue("VISITOR",&temptext[0]);
#ifndef	MIG_DEMO_VER
			else
				DisplayFragDialogue("VISITOR",&temptext[0]);
#endif
		}
		else
		{
			VisitorsBook=new VISITORINFO;

			VisitorsBook->vis_name=new char[strlen(name)+1];

			strcpy(VisitorsBook->vis_name,name);
			VisitorsBook->vis_status=FALSE;
			VisitorsBook->next=NULL;

			char temptext[256];
			strcpy(&temptext[0],name);
			strcat(&temptext[0]," has added name to visitor book");

			if ((H2H_Player+mySlot)->status==CPS_READYROOM)
				DisplayReadyDialogue("VISITOR",&temptext[0]);
#ifndef	MIG_DEMO_VER
			else
				DisplayFragDialogue("VISITOR",&temptext[0]);
#endif
		}
	}
}

//------------------------------------------------------------------------------
//Procedure		RemoveNameFromVisitorsBook
//Author		Andy McMaster
//Date			Fri 12 Jun 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::RemoveNameFromVisitorsBook(char* name)
{
	if (Host)
	{
		if (VisitorsBook)
		{
			LPVISITORINFO a,b;

			a=b=VisitorsBook;

			a=a->next;

			if (!strcmp(b->vis_name,name))
			{
				b->next=NULL;
				delete [] b->vis_name;
				delete b;
				VisitorsBook=a;
			}
			else
			{
				while (a)
				{
					if (!strcmp(a->vis_name,name))
					{
						b->next=a->next;

						a->next=NULL;
						delete [] a->vis_name;
						delete a;
						
						break;
					}
					a=a->next;
					b=b->next;
				}
			}
		}
	}
}

//------------------------------------------------------------------------------
//Procedure		ToggleVisitorStatus
//Author		Andy McMaster
//Date			Fri 12 Jun 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::ToggleVisitorStatus(char* name)
{
	LPVISITORINFO a=VisitorsBook;

	while (a)
	{
		if (!strcmp(a->vis_name,name))
		{
			if (a->vis_status)
				a->vis_status=FALSE;
			else
				a->vis_status=TRUE;

			break;
		}

		a=a->next;
	}
}

//------------------------------------------------------------------------------
//Procedure		SendUpdateToVisitorsBook
//Author		Andy McMaster
//Date			Mon 15 Jun 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::SendUpdateToVisitorsBook(char* name,Bool status)
{
	INITINFO info;
	ULong	from=myDPlayID,to=DPID_ALLPLAYERS; //,t=0;
	HRESULT res;

	info.ID=status;
	strcpy(info.Name,name);
	info.PacketID=PID_VISITORUPDATE;

	res=lpDP4->Send(from,to,0,&info,sizeof(INITINFO));
}


//------------------------------------------------------------------------------
//Procedure		DeleteLobbyInfo
//Author		Andy McMaster
//Date			Mon 6 Jul 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::DeleteLobbyInfo()
{
	if (lpDPL)
		lpDPL->Release();
	lpDPL=NULL;

	if (templpDPC)
		delete [] templpDPC;
	templpDPC=NULL;
}

//------------------------------------------------------------------------------
//Procedure		RunAggregatorFromReadyRoom
//Author		Andy McMaster
//Date			Tue 7 Jul 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::RunAggregatorFromReadyRoom()
{
}

//------------------------------------------------------------------------------
//Procedure		DeleteVisitorBook
//Author		Andy McMaster
//Date			Mon 13 Jul 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::DeleteVisitorBook()
{
	LPVISITORINFO a,b;

	a=VisitorsBook;

	while (a)
	{
		delete [] a->vis_name;
		b=a->next;
		delete a;
		a=b;
	}
	VisitorsBook=NULL;
}

//------------------------------------------------------------------------------
//Procedure		DeleteSessionList
//Author		Andy McMaster
//Date			Tue 14 Jul 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::DeleteSessionList()
{
	LPENUMSESSION temp1,temp2;
	temp1=SessionList;

	while (temp1)
	{
		delete[]temp1->sname;

		temp2=temp1->Next;
		temp1->Next=NULL;

		delete temp1;

		temp1=temp2;
	}
	SessionList=NULL;
}

//------------------------------------------------------------------------------
//Procedure		CheckPassword
//Author		Andy McMaster
//Date			Tue 28 Jul 1998
//
//Description	check if password is correct and send message
//				
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::CheckPassword(char* pword,char* name,ULong player)
{
	ULong pwordOK=0;
	HRESULT res;
	ULong from=myDPlayID,to=player;
	COMMONDATA pack;

	if (!strcmp(pword,&Password[0]))
		pwordOK=1;
	else
	{
// check in visitors book

		LPVISITORINFO	temp=_DPlay.VisitorsBook;

		while (temp)
		{
			if (!strcmp(temp->vis_name,name))
			{
// found player
				if (temp->vis_status)
					pwordOK=1;

				break;
			}
			temp=temp->next;
		}
	}

	pack.PacketID=PID_PASSWORDVALID;
	pack.PlayerID=pwordOK;

	SendMessageToAll((char*)&pack,sizeof(COMMONDATA));
}

//------------------------------------------------------------------------------
//Procedure		SetUpPlayer
//Author		Andy McMaster
//Date			Tue 28 Jul 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool DPlay::SetUpPlayer()
{
	if(Host)
	{
// if I am the host then set up aggregator ID 
// create group and get ID

// aggregator gets its own thread - provide handle
		if (lpDP4->CreatePlayer ( &aggID, NULL, Master_3d.htable[Master_3d.EVENT_AGGREGATOR], NULL,0,0)!=DP_OK)
			return FALSE;

		if (lpDP4->CreateGroup( &playergroupID,NULL,NULL,0,0)!=DP_OK)
			return FALSE;
	}

	if (lpDP4->CreatePlayer ( &myDPlayID, NULL, NULL, NULL,0,0)!=DP_OK)
		return FALSE;

	PlayerCreated=TRUE;

	return TRUE;
}

//------------------------------------------------------------------------------
//Procedure		AttemptToJoin
//Author		Andy McMaster
//Date			Tue 28 Jul 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool DPlay::AttemptToJoin()
{
 	HRESULT res;
	PASSWORDPACK pack;
	ULong from=myDPlayID,to=DPID_ALLPLAYERS;
	Bool	result=FALSE;

	char* Buffer;
	ULong	Buflen;
	
	pack.PacketID=PID_PASSWORD;
	pack.PlayerID=myDPlayID;
	strncpy(&pack.pword[0],&Password[0],10);
	strcpy(&pack.name[0],&PlayerName[0]);


	res=lpDP4->Send(from,to,0,&pack,sizeof(PASSWORDPACK));

	if (res!=DP_OK)
		return FALSE;

// NEEDTIMEOUT
	ULong now=_Miles.GetSysTime();

	CommsTimeout time(now,CommsTimeoutLength);

	while (!result)
	{
		now=_Miles.GetSysTime();

		if (time.TimedOut(now))
			return FALSE;

		if (ReceiveNextMessage(Buffer,Buflen,from,to,0))
		{
			pack=*(LPPASSWORDPACK)Buffer;

			if (pack.PacketID==PID_PASSWORDVALID)
				result=TRUE;
		}
	}

	if (pack.PlayerID!=0)
		return TRUE;

	return FALSE;
}

//------------------------------------------------------------------------------
//Procedure		ReceiveNextMessage
//Author		Andy McMaster
//Date			Fri 7 Aug 1998
//
//Description	General receive routine.
//				All messages must be handled. (including system messages)
//				No excuses allowed!
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::ReceiveNextMessage(char*&data, ULong& len, ULong& from,ULong &To,ULong flags)
{
	HRESULT res;
	bool got=false;
	bool reval=false;

	if (!PlayerCreated) 
		return FALSE;

// receive message to mydplayid in case I am aggregator. Dont want to receive packets 
// sent to aggregator here!!!!
	while (true)
	{
		res=lpDP4->Receive(&from, &To, flags, CommsPacketPtr, &CommsPacketLength);
		if (res==DPERR_BUFFERTOOSMALL)
		{
			delete [] CommsPacketPtr;
			CommsPacketPtr=new char[CommsPacketLength];
			if (!CommsPacketPtr)
				_Error.EmitSysErr("Out of memory");
		}
		else if (res==DP_OK)
		{
			data=CommsPacketPtr;
			len=CommsPacketLength;
			return TRUE;
		}
		else
			break;
	}

	return FALSE;
}

//------------------------------------------------------------------------------
//Procedure		SendGameDetails
//Author		Andy McMaster
//Date			Tue 13 Oct 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::SendGameDetails()
{
	GAMEDETAILS pack;
	COMMONDATA	cpack;

	if (AllowJoins)
	{
		pack.PacketID=PID_GAMEDETAILSINFO;
		pack.GameType=GameType;
		pack.GameIndex=GameIndex;
		pack.DataRate=RateDivider;

		SendMessageToAll((char*)&pack,sizeof(GAMEDETAILS));
	}
	else
	{
		cpack.PacketID=PID_HOSTBUSY;
		SendMessageToAll((char*)&cpack,sizeof(COMMONDATA));
	}
}

//------------------------------------------------------------------------------
//Procedure		UpdatePlayerInfo
//Author		Andy McMaster
//Date			Wed 14 Oct 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::UpdatePlayerInfo()
{
	if (!SendMyPlayerInfo (true))
	{
		return FALSE;
	}

	return TRUE;
}

//------------------------------------------------------------------------------
//Procedure		SendMyPlayerInfo
//Author		Andy McMaster
//Date			Wed 14 Oct 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
//DeadCode AMM 13May99 void	DPlay::SendMyPlayerInfo()
bool	DPlay::SendMyPlayerInfo(bool request)
{
	UIPLAYERDATA pack;

	pack.PacketID=PID_PLAYERUPDATE;
	pack.Slot=mySlot; 

	CopyBuffer((char*)&pack.playerinfo,(char*)&H2H_Player[mySlot],sizeof(H2HPlayerInfo));

	if (!request)
	{
		if (!SendGMessageToPlayersTimeout((char*)&pack,sizeof(UIPLAYERDATA)))
			return false;
	}
	else
	{
		SendMessageToPlayers((char*)&pack,sizeof(UIPLAYERDATA));
	}

	return true;
}

//------------------------------------------------------------------------------
//Procedure		GetNextAvailableSlot
//Author		Andy McMaster
//Date			Thu 22 Oct 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
SLong	DPlay::GetNextAvailableSlot()
{
	ULong n;

	for (n=0;n<MAXPLAYERS;n++)
	{
		if (H2H_Player[n].status==CPS_NONE)
			return n;
	}

	return -1;
}

//------------------------------------------------------------------------------
//Procedure		ProcessPrefsPacket
//Author		Andy McMaster
//Date			Wed 28 Oct 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::ProcessPrefsPacket(char* pack)
{
	PUIPREFSDATA pUIPrefsData;

	pUIPrefsData = (PUIPREFSDATA)pack;

// ignore Coordinated rudder, translucent smoke, priority messages, stick stiffness etc
	bool rud;														  //RDH 20/05/99
	Bool smoke,mess,stick;
	bool frate;														  //RDH 20/05/99
	bool	autopadlock;

	bool	ff_gun,ff_buffet,ff_aero,ff_frame; //DAW 08/11/99

	ff_gun=Save_Data.flightdifficulty[FD_FF_GUN]; //DAW 08/11/99
	ff_buffet=Save_Data.flightdifficulty[FD_FF_BUFFET]; //DAW 08/11/99
	ff_aero=Save_Data.flightdifficulty[FD_FF_AERODYNAMIC]; //DAW 08/11/99
	ff_frame=Save_Data.flightdifficulty[FD_FF_AIRFRAME]; //DAW 08/11/99

	frate=Save_Data.gamedifficulty[FRAME_RATE_DISPLAY];

	rud=Save_Data.flightdifficulty[FD_COORDINATEDRUDDER];

	autopadlock=Save_Data.gamedifficulty[GD_AUTOPADLOCKTOG];

	Save_Data.flightdifficulty	=	pUIPrefsData->flightdifficulty;
	Save_Data.gamedifficulty	=	pUIPrefsData->gamedifficulty;
	Save_Data.targetsize		=	pUIPrefsData->targetsize;
	Save_Data.autopilotskillUN	=	pUIPrefsData->autopilotskillUN;
	Save_Data.autopilotskillRED	=	pUIPrefsData->autopilotskillRED;


	if (ff_gun) //DAW 08/11/99
		Save_Data.flightdifficulty|=FD_FF_GUN; //DAW 08/11/99
	else //DAW 08/11/99
		Save_Data.flightdifficulty%=FD_FF_GUN; //DAW 08/11/99

	if (ff_buffet) //DAW 08/11/99
		Save_Data.flightdifficulty|=FD_FF_BUFFET; //DAW 08/11/99
	else //DAW 08/11/99
		Save_Data.flightdifficulty%=FD_FF_BUFFET; //DAW 08/11/99

	if (ff_aero) //DAW 08/11/99
		Save_Data.flightdifficulty|=FD_FF_AERODYNAMIC; //DAW 08/11/99
	else //DAW 08/11/99
		Save_Data.flightdifficulty%=FD_FF_AERODYNAMIC; //DAW 08/11/99

	if (ff_frame) //DAW 08/11/99
		Save_Data.flightdifficulty|=FD_FF_AIRFRAME; //DAW 08/11/99
	else //DAW 08/11/99
		Save_Data.flightdifficulty%=FD_FF_AIRFRAME; //DAW 08/11/99


	if (frate)										
		Save_Data.gamedifficulty|=FRAME_RATE_DISPLAY;
	else 											
		Save_Data.gamedifficulty%=FRAME_RATE_DISPLAY;

	if (autopadlock)
		Save_Data.gamedifficulty|=GD_AUTOPADLOCKTOG;
	else
		Save_Data.gamedifficulty%=GD_AUTOPADLOCKTOG;
}

//------------------------------------------------------------------------------
//Procedure		AllPlayersHaveSlots
//Author		Andy McMaster
//Date			Tue 3 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::AllPlayersHaveSlots()
{
	UByte num=0,n;

	for (n=0;n<MAXPLAYERS;n++)
	{
		if (H2H_Player[n].position!=-1 && H2H_Player[n].squadron!=-1)
		{
			num++;
		}
	}

	if (num==CurrPlayers)
		return TRUE;

	return FALSE;
}

//------------------------------------------------------------------------------
//Procedure		SendInFragMessage
//Author		Andy McMaster
//Date			Tue 3 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::SendInFragMessage ()
{
	COMMONDATA pack;

	pack.PacketID=PID_INFRAG;

	SendMessageToPlayers ((char*)&pack, sizeof(COMMONDATA));
}

//------------------------------------------------------------------------------
//Procedure		SendInMapMessage
//Author		Andy McMaster
//Date			Tue 3 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::SendInMapMessage ()
{
	if (!PlayerCreated) return;										  //JIM 25/01/99
	COMMONDATA pack;

	pack.PacketID=PID_INMAP;

	H2H_Player[mySlot].status=CPS_MAP;
	SendMessageToPlayers ((char*)&pack, sizeof(COMMONDATA));
}

//------------------------------------------------------------------------------
//Procedure		SendInMissionBriefMessage
//Author		Andy McMaster
//Date			Tue 3 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::SendInMissionBriefMessage ()
{
	COMMONDATA pack;

	pack.PacketID=PID_INMISSIONBRIEF;

	SendMessageToPlayers ((char*)&pack, sizeof(COMMONDATA));
}

//------------------------------------------------------------------------------
//Procedure		SendInRadioMessage
//Author		Andy McMaster
//Date			Tue 3 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::SendInRadioMessage ()
{
	COMMONDATA pack;

	pack.PacketID=PID_INRADIO;

	SendMessageToPlayers ((char*)&pack, sizeof(COMMONDATA));
}

//------------------------------------------------------------------------------
//Procedure		SendInReadyRoomMessage
//Author		Andy McMaster
//Date			Tue 3 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::SendInReadyRoomMessage ()
{
	COMMONDATA pack;

	pack.PacketID=PID_INREADYROOM;

	SendMessageToPlayers ((char*)&pack, sizeof(COMMONDATA));
}

//------------------------------------------------------------------------------
//Procedure		SendCS
//Author		Andy McMaster
//Date			Sun 8 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::SendCS(UByte* info,ULong size, Bool init)
{
	CSQUICKSTRUC	pack;
	COMMONDATA g;
	ULong n;

	if (init)
	{
		pack.PacketID=PID_CSQUICKINIT;
	}
	else
	{
		pack.PacketID=PID_CSQUICKINFO;

// need to unassign all players as mission has changed
		for (n=0;n<MAXPLAYERS;n++)
		{
			H2H_Player[n].squadron=-1;
			H2H_Player[n].position=-1;
		}

		MMC.playersquadron=-1;
		MMC.playeracnum=-1;
	}

	ULong numpackets=size/500;

	if (size%500)
		numpackets++;

	g.PacketID=PID_CSSTRUC;
	g.PlayerID=numpackets;
	g.Slot=size;

	if (init)
	{
		SendMessageToAll((char*)&g, sizeof(COMMONDATA));
	}
	else
	{
		SendMessageToAll((char*)&g, sizeof(COMMONDATA));
	}

	ULong	index=0;
	ULong	copysize;
	CSSTRUCPART csp;
	UByteP ptr=info;

	while (numpackets--)
	{
		csp.PacketID=PID_CSSTRUCBINARY;
		csp.index=index++;

		if (numpackets)
			copysize=500;
		else
			copysize=size%500;

		csp.size=copysize;
		csp.newmissionnum=GameIndex;

		CopyMemory(&csp.data,ptr,copysize);
		ptr+=copysize;

		if (init)
		{
			SendMessageToAll((char*)&csp,sizeof(CSSTRUCPART));
		}
		else
		{
			SendMessageToAll((char*)&csp,sizeof(CSSTRUCPART));
		}
	}
}

//------------------------------------------------------------------------------
//Procedure		GetCS
//Author		Andy McMaster
//Date			Sun 8 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::GetCS()
{
	char* Buffer;
	ULong	BufferLen=0;
	Bool	Got=FALSE;
	ULong From;
	ULong size,numparts;

	ULong now=_Miles.GetSysTime();
	CommsTimeout time(now,CommsTimeoutLength);

	while(!Got)
	{
		now=_Miles.GetSysTime();

		if (time.TimedOut(now))
			return FALSE;
		
		ULong to=0;
		if (ReceiveNextMessage(Buffer,BufferLen,From,to,0))
		{
			if (From==0)
			{
				ProcessSystemMessage(Buffer,CPS_NONE);
			}
			else if (BufferLen!=sizeof(AGGSENDPACKET))
			{
				if (((PCOMMONDATA)Buffer)->PacketID == PID_CSSTRUC)
				{
					size=((PCOMMONDATA)Buffer)->Slot;
					numparts=((PCOMMONDATA)Buffer)->PlayerID;
					Got=TRUE;
				}
			}
		}
	}
// get parts

	char* RecPacket;
	ULong RecPacketLen=0,from;
	ULong rec=0;
	UByte*	struc=new UByte[size];

	time.Init(now,(CommsTimeoutLength*2));

	while (rec!=numparts)
	{
		now=timeGetTime();

		if (time.TimedOut(now))
		{
			delete [] struc;
			return FALSE;
		}

		ULong to=0;
		if (ReceiveNextMessage (RecPacket, RecPacketLen,from,to,0))
		{
// if we are getting info about game initally dont bother with any other messages

			if (from!=0 && RecPacketLen!=sizeof(AGGSENDPACKET))
			{
				if(((PCOMMONDATA)RecPacket)->PacketID == PID_CSSTRUCBINARY)
				{
					LPCSSTRUCPART csp=(LPCSSTRUCPART)RecPacket;

					GameIndex=csp->newmissionnum;

					UByteP temp=struc;

					temp+=(csp->index)*500;

					CopyMemory(temp,csp->data,csp->size);

					rec++;
				}
			}
		}
	}

	UpdateCSQuick((UByte*)struc,GameIndex);

	delete [] struc;
	return TRUE;
}

//------------------------------------------------------------------------------
//Procedure		GetCSQuickStruc
//Author		Andy McMaster
//Date			Sun 8 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::GetCSQuickStruc()
{
	SendCSRequest();
	GetCS();
}

//------------------------------------------------------------------------------
//Procedure		SendCSRequest
//Author		Andy McMaster
//Date			Sun 8 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::SendCSRequest()
{
	COMMONDATA p;
	p.PacketID=PID_CSQUICKREQUEST;
	ULong retries=10;											//AMM 07Jul99

	while (!SendMessageToAll((char*)&p,sizeof(COMMONDATA)))
	{
		ULong end=timeGetTime()+100; // 10th sec

		while (timeGetTime()<end)
		{
			Sleep(0);
		}
		retries--;

		if (!retries)
			break;
	}
}

//------------------------------------------------------------------------------
//Procedure		SendMyMessages
//Author		Andy McMaster
//Date			Wed 11 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
//DeadCode AMM 23May99 void	DPlay::SendMyMessages()
bool	DPlay::SendMyMessages(bool request)
{
	MESSAGEPACKET p;
	ULong n;

	p.PacketID=PID_MESSAGES;

	for (n=0;n<NUMRADIOMESSAGES;n++)
	{
		strcpy (p.messages[n],Messages[mySlot][n]);
	}

	if (request)
	{
		if (SendMessageToAll((char*)&p,sizeof(MESSAGEPACKET)))
			return true;

		return false;
	}
	else
	{
		return (SendGMessageToPlayersTimeout((char*)&p,sizeof(MESSAGEPACKET)));
	}
}

//------------------------------------------------------------------------------
//Procedure		ReceiveMessages
//Author		Andy McMaster
//Date			Wed 11 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::ReceiveMessages(UByteP p,ULong from)
{
	ULong n,slot=0;
	LPMESSAGEPACKET m=(LPMESSAGEPACKET)p;

	for (n=0;n<MAXPLAYERS;n++)
	{
		if (H2H_Player[n].dpid==from)
		{
			slot=n;
			break;
		}
	}

	if (n!=MAXPLAYERS)
	{
		for (n=0;n<NUMRADIOMESSAGES;n++)
		{
			strcpy(Messages[slot][n],m->messages[n]);
		}
	}
}

//------------------------------------------------------------------------------
//Procedure		DisableJoins
//Author		Andy McMaster
//Date			Fri 13 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::DisableJoins()
{
	AllowJoins=FALSE;
}

//------------------------------------------------------------------------------
//Procedure		EnableJoins
//Author		Andy McMaster
//Date			Fri 13 Nov 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::EnableJoins()
{
	AllowJoins=TRUE;
}

//------------------------------------------------------------------------------
//Procedure		SelectPlayerToChatTo
//Author		Andy McMaster
//Date			Tue 1 Dec 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::SelectPlayerToChatTo(ULong playerslot)
{
	ULong realslot,n;
	SLong id=-1;

	for (n=0;n<MAXPLAYERS;n++)
	{
		if ((H2H_Player + n)->MyTeam == TS_UN || (H2H_Player + n)->MyTeam == TSIDE_NONE)
		{
			if (n==playerslot)
			{
				id=n;
				break;
			}
		}
	}

	if (id<0)
	{
		for (n=0;n<MAXPLAYERS;n++)
		{
			if ((H2H_Player+n)->MyTeam==TS_COMMIE)
			{
				if (n==playerslot)
				{
					id=n;
					break;
				}
			}
		}
	}

	if (id>=0)
	{
		sendtowho=id;
	}
	else
	{
		sendtowho=255;
	}
}


//------------------------------------------------------------------------------
//Procedure		SelectPlayerToChatTo
//Author		Andy McMaster
//Date			Mon 11 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::SelectPlayerToChatTo(ULong position, ULong squadron)
{
	ULong n;
	SLong id=-1;

	for (n=0;n<MAXPLAYERS;n++)
	{
		if (H2H_Player[n].position==position
		&& H2H_Player[n].squadron==squadron)
		{
			id=n;
			break;
		}
	}

	if (id>=0)
	{
		sendtowho=id;
	}
	else
	{
		sendtowho=255;
	}

}


void	DPlay::ResetAllocPacket()
{
	ULong n;

	for (n=0;n<MAXPLAYERS;n++)
	{
		AllocPacket[n]=0;
	}
}

void	DPlay::ResetCommsGame()
{
	ULong n;

	SimulateExitKey=FALSE;

// unassign all players

	if (GameType>TEAMPLAY)
	{
		for(n=0;n<MAXPLAYERS;n++)
		{
			H2H_Player[n].squadron=-1;
			H2H_Player[n].position=-1;
		}
		MMC.playersquadron=-1;
	}
}

//------------------------------------------------------------------------------
//Procedure		UpdateMessages
//Author		Andy McMaster
//Date			Wed 9 Dec 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
bool	DPlay::UpdateMessages()
{
	if (!SendMyMessages(false))
	{
		return false;
	}

	return true;
}

//------------------------------------------------------------------------------
//Procedure		UpdateMissionConditions
//Author		Andy McMaster
//Date			Tue 5 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::UpdateMissionConditions()
{
	ULong RecPacketLen;
	ULong from;
	char* RecPacket;

// NEEDTIMEOUT
	if (Host)
	{
		if (!SendMissionConditions (false))
			return FALSE;
	}
	else
	{
// Receive Prefs Packet
		ULong now=_Miles.GetSysTime();
		CommsTimeout time(now,CommsTimeoutLength);
		for (;;)
		{
			now=_Miles.GetSysTime();

			if (time.TimedOut(now))
				_Error.SayAndQuit("Timed out (UMC)");

			ULong to=myDPlayID;
			if (ReceiveNextMessage(RecPacket, RecPacketLen,from,to,DPRECEIVE_TOPLAYER))
			{
				if (from==0)
				{
					ProcessSystemMessage(RecPacket,RecPacketLen);
				}
				else if (from!=aggID)
				{
					PUIPLAYERDATA pUIPlayerData = (PUIPLAYERDATA)RecPacket;

					if (pUIPlayerData->PacketID == PID_MISSIONCONDITIONS)
				   	{
						ProcessConditionsPacket(RecPacket);
						break;

					}
					else
					{
						ProcessPlayerMessage(RecPacket,RecPacketLen,from,CPS_GAMESTARTUP);
					}
				}
			}
		}
	}
	return TRUE;
}

//------------------------------------------------------------------------------
//Procedure		SendMissionConditions
//Author		Andy McMaster
//Date			Tue 5 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::SendMissionConditions(bool request)
{
	CONDITIONSDATA 	cd;
	MISSIONCONDS	mc;

	if (PlayerCreated && Host)
	{
		cd.PacketID=PID_MISSIONCONDITIONS;

		mc.TempVar=MMC.Sky.TempVar;
		mc.Temp0=MMC.Sky.Temp0;
		mc.Press0=MMC.Sky.Press0;
		mc.Density0=MMC.Sky.Density0;
		mc.wind0=MMC.Sky.wind0;
		mc.dir0=MMC.Sky.dir0;				
		mc.windalt=MMC.Sky.windalt;			
		mc.diralt=MMC.Sky.diralt;				
		mc.Wind0=MMC.Sky.Wind0;				
		mc.WindAlt=MMC.Sky.WindAlt;			
		mc.WindAltHeight=MMC.Sky.WindAltHeight;		
		mc.MinDuration=MMC.Sky.MinDuration;		
		mc.MaxDuration=MMC.Sky.MaxDuration;		
		mc.MinMagnitude=MMC.Sky.MinMagnitude;		
		mc.MaxMagnitude=MMC.Sky.MaxMagnitude;		
		mc.Frequency=MMC.Sky.Frequency;		
		mc.ContrailBandCentre=MMC.Sky.ContrailBandCentre;
		mc.ContrailBandWidth=MMC.Sky.ContrailBandWidth;
		mc.Visibility=MMC.Sky.Visibility;			
		mc.Conditions=MMC.Sky.Conditions;			
		mc.CloudLayer=MMC.Sky.CloudLayer;			
		mc.MistInValley=MMC.Sky.MistInValley;

		if (sizeof(MISSIONCONDS)>512)
			_Error.SayAndQuit("Mission Conditions>512");

		memcpy(&cd.conds,&mc,sizeof(MISSIONCONDS));

		if (request)
		{
			return (SendMessageToAll((char*)&cd,sizeof(CONDITIONSDATA)));
		}
		else
		{
			if (SendGMessageToPlayersTimeout((char*)&cd,sizeof(CONDITIONSDATA)))
				return TRUE;
		}
	}

	return FALSE;
}

//------------------------------------------------------------------------------
//Procedure		ProcessConditionsPacket
//Author		Andy McMaster
//Date			Tue 5 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::ProcessConditionsPacket(char* message)
{
	LPCONDITIONSDATA 	cd;
	LPMISSIONCONDS	mc;

	cd=(LPCONDITIONSDATA)message;
	mc=(LPMISSIONCONDS)cd->conds;

	MMC.Sky.TempVar=mc->TempVar;
	MMC.Sky.Temp0=mc->Temp0;
	MMC.Sky.Press0=mc->Press0;
	MMC.Sky.Density0=mc->Density0;
	MMC.Sky.wind0=mc->wind0;
	MMC.Sky.dir0=mc->dir0;
	MMC.Sky.windalt=mc->windalt;
	MMC.Sky.diralt=mc->diralt;
	MMC.Sky.Wind0=mc->Wind0;
	MMC.Sky.WindAlt=mc->WindAlt;
	MMC.Sky.WindAltHeight=mc->WindAltHeight;	
	MMC.Sky.MinDuration=mc->MinDuration;
	MMC.Sky.MaxDuration=mc->MaxDuration ;
	MMC.Sky.MinMagnitude=mc->MinMagnitude;
	MMC.Sky.MaxMagnitude=mc->MaxMagnitude;
	MMC.Sky.Frequency=mc->Frequency;
	MMC.Sky.ContrailBandCentre=mc->ContrailBandCentre;
	MMC.Sky.ContrailBandWidth=mc->ContrailBandWidth;
	MMC.Sky.Visibility=mc->Visibility;
	MMC.Sky.Conditions=mc->Conditions;
	MMC.Sky.CloudLayer=mc->CloudLayer;
	MMC.Sky.MistInValley=mc->MistInValley;
}

//------------------------------------------------------------------------------
//Procedure		DisplayPlayerJoiningMessage
//Author		Andy McMaster
//Date			Mon 11 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::DisplayPlayerJoiningMessage(ULong slot)
{
	AirStrucPtr i=Persons2::PlayerSeenAC;
	AirStrucPtr ac=*Persons2::ConvertPtrUID((UniqueID)AllocPacket[slot]);
	DisplayPlayerMessage(ac,ac,ST_PLAYERJOINING,0);
}

//------------------------------------------------------------------------------
//Procedure		DisplayResyncingMessage
//Author		Andy McMaster
//Date			Mon 11 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::DisplayResyncingMessage()
{
//Deadcode
}

//------------------------------------------------------------------------------
//Procedure		DisplayResyncOKMessage
//Author		Andy McMaster
//Date			Mon 11 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::DisplayResyncOKMessage()
{
//DeadCode
}

//------------------------------------------------------------------------------
//Procedure		SendSavegame
//Author		Andy McMaster
//Date			Thu 14 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
//DeadCode AMM 12May99 void	DPlay::SendSaveGame(bool score)
bool	DPlay::SendSaveGame(bool score,bool startup)
{
// copy savegame file into as many packets as needed. Send a header packet saying how
// many packets to expect, and inital segment of save data. Subsequent packets have
// header saying which packet they are in the order (in case of out of order arrivals)

	COMMONDATA cd;
	char savedgamename[150];
	ULong	savesize,numpackets;
	HANDLE	savegame;

	strcpy(savedgamename,"dcomms.dat");

	GetCommsSavename(savedgamename);

	if (H2H_Player[mySlot].status!=CPS_3D)
		_Replay.SaveTempSaveGame("dcomms.dat",true);

	savegame=CreateFile(
		savedgamename,
		GENERIC_READ|GENERIC_WRITE,
		FILE_SHARE_READ|FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		NULL,
		NULL);

	if (savegame!=INVALID_HANDLE_VALUE)
	{
		savesize=GetFileSize(savegame,NULL);
		numpackets=savesize/500;
		if (savesize%500)
			numpackets++;

		cd.PacketID=PID_SAVEGAME;

		cd.PlayerID=numpackets;
		cd.Slot=savesize;

		if (startup)
		{
 			if (!SendMessageToAll((char*)&cd,sizeof(COMMONDATA)))
				return false;
		}
		else
		{
			if (!SendGMessageToPlayersTimeout((char*)&cd,sizeof(COMMONDATA)))
				return false;
		}

		ULong	index=0;
		SAVEGAMEPACKET sgp;
		ULong	readsize;
		ULong	numread;

		while (numpackets--)
		{
			sgp.PacketID=PID_SAVEGAMEBINARY;
			sgp.index=index++;

			if (numpackets)
				readsize=500;
			else
				readsize=savesize%500;

			sgp.size=readsize;

			ReadFile(
				savegame,
				&sgp.data,
				readsize,
				&numread,
				NULL);

			if (startup)
			{
 				if (!SendMessageToAll((char*)&sgp,sizeof(SAVEGAMEPACKET)))
					return false;
			}
			else
			{
				if (!SendGMessageToPlayersTimeout((char*)&sgp,sizeof(SAVEGAMEPACKET)))
					return false;
			}
		}
	}

	return true;
}

//------------------------------------------------------------------------------
//Procedure		ReceiveSavegame
//Author		Andy McMaster
//Date			Thu 14 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
bool	DPlay::ReceiveSaveGame(bool startup,ULong num,ULong size)
{
	char* RecPacket;
	ULong RecPacketLen=0,from;
	ULong now=_Miles.GetSysTime();
	ULong rec=0;
	UByte*	save=new UByte[size];

	CommsTimeout time(now,(CommsTimeoutLength*2));

	while (rec!=num)
	{
		now=_Miles.GetSysTime();

		if (time.TimedOut(now))
		{
			delete [] save;
			return false;
		}

		ULong to=myDPlayID;
		if (ReceiveNextMessage (RecPacket, RecPacketLen,from,to,DPRECEIVE_TOPLAYER))
		{
			if (startup)
			{
// if we are getting info about game initally dont bother with any other messages

				if (from!=0) // && RecPacketLen!=sizeof(AGGSENDPACKET))
				{
					if(((PCOMMONDATA)RecPacket)->PacketID == PID_SAVEGAMEBINARY)
					{
						rec++;
						UpdateSaveGame(save,RecPacket);
					}
				}
			}
			else
			{
				if (from==0)
				{
					ProcessSystemMessage(RecPacket,CPS_GAMESTARTUP);
				}
				else if (from!=aggID)
				{
					if(((PCOMMONDATA)RecPacket)->PacketID == PID_SAVEGAMEBINARY)
					{
						rec++;
						UpdateSaveGame(save,RecPacket);
					}
					else
					{
						ProcessPlayerMessage(RecPacket,RecPacketLen,from,CPS_GAMESTARTUP);
					}
				}
			}
		}
	}

	bool retval=SaveDummyCommsSaveGame(save,size);

	if (retval)
	{
		retval=LoadDummySavegame("dcomms.dat");
		if (H2H_Player[mySlot].status==CPS_FRAG)	//AMM 07/06/99
			FragChanged=true;					//AMM 07/06/99
	}

	delete [] save;
	return retval;
}

//------------------------------------------------------------------------------
//Procedure		UpdateSaveGame
//Author		Andy McMaster
//Date			Mon 18 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::UpdateSaveGame(UByte* savegamedata,char* pack)
{
	LPSAVEGAMEPACKET sgp;
	UByteP temp=savegamedata;

	sgp=(LPSAVEGAMEPACKET)pack;
	temp+=((sgp->index)*500);

	memcpy(temp,sgp->data,sgp->size);
}

//------------------------------------------------------------------------------
//Procedure		SaveDummyCommsSaveGame
//Author		Andy McMaster
//Date			Mon 18 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
bool	DPlay::SaveDummyCommsSaveGame(UByte* data,ULong size)
{
	char	dummyname[150];
	HANDLE	dummyfile;
	ULong temp;
	bool	retval=false;

	strcpy(dummyname,"dcomms.dat");

	GetCommsSavename(dummyname);

	dummyfile=CreateFile(
		dummyname,
		GENERIC_WRITE|GENERIC_WRITE,
		FILE_SHARE_READ|FILE_SHARE_WRITE,
		NULL,
		CREATE_ALWAYS,
		NULL,
		NULL);

	if (dummyfile!=INVALID_HANDLE_VALUE)
	{
		WriteFile(
			dummyfile,
			data,
			size,
			&temp,
			NULL);

		retval=true;
	}

	CloseHandle(dummyfile);

	return retval;
}

//------------------------------------------------------------------------------
//Procedure		ReceiveStartupSaveGame
//Author		Andy McMaster
//Date			Mon 18 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
bool	DPlay::ReceiveStartupSaveGame(bool realstartup)
{
	char* packet;
	ULong packlen,from;
	ULong now=_Miles.GetSysTime();
	bool	gotOK=false;

	CommsTimeout time(now,(CommsTimeoutLength*2));

	while (!gotOK)
	{
		now=_Miles.GetSysTime();

		if (time.TimedOut(now))
			return false;

		ULong to;
		ULong flags;
		if (realstartup)
		{
			to=0;
			flags=0;
		}
		else
		{
			to=myDPlayID;
			flags=DPRECEIVE_TOPLAYER;
		}

		if (ReceiveNextMessage(packet,packlen,from,to,flags))
		{
			if (realstartup)
			{
				if (((PCOMMONDATA)packet)->PacketID==PID_SAVEGAME)
				{
 					if (ReceiveSaveGame(true,((PCOMMONDATA)packet)->PlayerID,((PCOMMONDATA)packet)->Slot))
						gotOK=true;
				}
			}
			else
			{
				if (from==0)
				{
					ProcessSystemMessage(packet,CPS_GAMESTARTUP);
				}
				else if (from!=aggID)
				{
					if (((PCOMMONDATA)packet)->PacketID==PID_SAVEGAME)
					{
 						if (ReceiveSaveGame(true,((PCOMMONDATA)packet)->PlayerID,((PCOMMONDATA)packet)->Slot))
							gotOK=true;
					}
					else
					{
						ProcessPlayerMessage(packet,packlen,from,CPS_GAMESTARTUP);
					}
				}
			}
		}
	}

	return true;
}

//------------------------------------------------------------------------------
//Procedure		JoinComms
//Author		Andy McMaster
//Date			Wed 20 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::JoinComms()
{
	_DPlay.UIPlayerType = PLAYER_GUEST;

// need a temp name to be able to create a player with
	strcpy(_DPlay.PlayerName,"temp name");

// need to get game details before going to locker room so that info can be filled
// in correctly....
	if (_DPlay.UINewPlayer(_DPlay.PlayerName,_DPlay.SessionName))
	{
// null temp player name
		strcpy (_DPlay.PlayerName,"");

		if (_DPlay.GetGameDetails())
		{
			return TRUE;
		}
		CommsMessage(IDS_HOSTBUSY);
	}

	SessionName[0]='/0';									//AMM 01Jul99
	strcpy(_DPlay.PlayerName,"");

	_DPlay.lpDP4->DestroyPlayer(_DPlay.myDPlayID);
	_DPlay.lpDP4->Close();

	return FALSE;
}

//------------------------------------------------------------------------------
//Procedure		FindGoodSession
//Author		Andy McMaster
//Date			Wed 20 Jan 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
Bool	DPlay::FindGoodSession()
{
	ULong now=_Miles.GetSysTime();
	CommsTimeout	time(now,CommsTimeoutLength);

	while (!time.TimedOut(_Miles.GetSysTime()))
	{
		_DPlay.UIGetSessionListUpdate();

		if (_DPlay.SessionList)
		{
			strncpy(_DPlay.SessionName,_DPlay.SessionList->sname,59);
			_DPlay.SessionName[59]=NULL;

			return TRUE;
		}
	}

	return FALSE;
}

//------------------------------------------------------------------------------
//Procedure		DeleteClaimBuffer
//Author		Andy McMaster
//Date			Fri 12 Mar 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::DeleteClaimBuffer()
{
	LPCLAIMER temp,temp1=HSB;

	while (temp1)
	{
		temp=temp1->next;
		delete temp1;
		temp1=temp;
	}
	HSB=NULL;
}


//------------------------------------------------------------------------------
//Procedure		ApplyBackupPilots
//Author		Andy McMaster
//Date			Thu 6 May 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::ApplyBackupPilots()
{
	for (int n=0;n<PILOTS_PER_CAMPAIGN;n++)
	{
		MMC.Active_Pilots[n].status=(pilotstatus)BackupPilots[n];
	}
}

//------------------------------------------------------------------------------
//Procedure		SendCampaignStruc
//Author		Andy McMaster
//Date			Thu 13 May 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
bool	DPlay::SendCampaignStruc(bool startup)
{
	COMMONDATA cd;
	ULong numpackets;
	ULong campsize=sizeof(Campaign);

	numpackets=campsize/500;
	if (campsize%500)
		numpackets++;

	cd.PacketID=PID_CAMPAIGNSTRUC;
	cd.PlayerID=numpackets;

	if (startup)
		SendMessageToAll((char*)&cd,sizeof(COMMONDATA));
	else
		SendGMessageToPlayersTimeout((char*)&cd,sizeof(COMMONDATA));

	ULong	index=0;
	ULong	copysize;
	ULong	numread;
	SAVEGAMEPACKET sgp;
	UByteP temp=(UByteP)&MMC;

	while (numpackets--)
	{
		sgp.PacketID=PID_CAMPAIGNSTRUCBINARY;
		sgp.index=index++;

		if (numpackets)
			copysize=500;
		else
			copysize=campsize%500;

		sgp.size=copysize;

		memcpy(&sgp.data,temp,copysize);
		temp+=copysize;

		if (startup)
		{
			SendMessageToAll((char*)&sgp,sizeof(SAVEGAMEPACKET));
		}
		else
		{
			if (!SendGMessageToPlayersTimeout((char*)&sgp,sizeof(SAVEGAMEPACKET)))
				return false;
		}
	}

	return true;
}

//------------------------------------------------------------------------------
//Procedure		ReceiveCampaignStruc
//Author		Andy McMaster
//Date			Thu 13 May 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
bool	 DPlay::ReceiveCampaignStruc()
{
	char* buffer;
	ULong buflen=0,from;
	ULong now=_Miles.GetSysTime();
	ULong rec=0,num;
	bool	got=false;

	CommsTimeout time(now,CommsTimeoutLength);

	while (!got)
	{
		now=_Miles.GetSysTime();

		if (time.TimedOut(now))
			return false;

		ULong to=myDPlayID;
		if (ReceiveNextMessage(buffer,buflen,from,to,DPRECEIVE_TOPLAYER))
		{
			if (from==0)
			{
				ProcessSystemMessage(buffer,buflen);
			}
			else if (from!=aggID)
			{
				if (((PCOMMONDATA)buffer)->PacketID==PID_CAMPAIGNSTRUC)
				{
					got=true;
					num=((PCOMMONDATA)buffer)->PlayerID;
				}
				else
				{
				 	ProcessPlayerMessage(buffer,buflen,from,CPS_GAMESTARTUP);
				}
			}
		}
	}

	now=_Miles.GetSysTime();
	time.Init(now,(CommsTimeoutLength*2));

	while (rec!=num)
	{
		now=_Miles.GetSysTime();

		if (time.TimedOut(now))
			return false;

		ULong to=myDPlayID;
		if (ReceiveNextMessage (buffer, buflen,from,to,DPRECEIVE_TOPLAYER))
		{
			if (from==0)
			{
				ProcessSystemMessage(buffer,buflen);
			}
			else if (from!=aggID)
			{
				LPSAVEGAMEPACKET sgp=(LPSAVEGAMEPACKET)buffer;

				if (sgp->PacketID==PID_CAMPAIGNSTRUCBINARY)
				{
					rec++;
					UByteP temp=(UByteP)&MMC;

					temp+=(500*(sgp->index));

					memcpy(temp,sgp->data,sgp->size);
				}
				else
				{
				 	ProcessPlayerMessage(buffer,buflen,from,CPS_GAMESTARTUP);
				}
			}
		}
	}

	return true;
}

//------------------------------------------------------------------------------
//Procedure		InitialFlagReset
//Author		Andy McMaster
//Date			Sun 6 Jun 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::InitialFlagReset()
{
// reset all flags etc before launching 3d as inital sync is on interrupt and can get
// called before flags are setup in SendInit and SendInit2 etc

	resyncbar=false;
	joiningplayerslot=-1;
	SuicideTime=0;
	AllowSuicide=TRUE;
	GameRunning=TRUE;
	deadplayers=0;
	accelselected=0;
	Implemented = TRUE;											//AMM 13May99
	firsttimein = TRUE; //AMM 18/05/99
	synched=FALSE; //AMM 18/05/99
	csync=false; //AMM 18/05/99
	ResyncPhase=FALSE; //AMM 18/05/99
	Initiator=FALSE; //AMM 18/05/99
	realfirsttimein=TRUE; //AMM 18/05/99
	resyncsgot=0; //AMM 18/05/99
	SimulateExitKey=FALSE; //AMM 18/05/99
	InitSyncData(true); //AMM 18/05/99
	FrameCount = 0; //AMM 18/05/99
	ResetSync=true; //AMM 18/05/99
	beginsyncflag=false;
	resetreceivesync=false;
	PlayerSync=false;
	HostQuit=false;
	resurrectend=false;

	BFieldToProcess=0;
	_Replay.DeleteFileAndGlobRefList(_Replay.bfgrlist);
}

//------------------------------------------------------------------------------
//Procedure		SendBackupRandomList
//Author		Andy McMaster
//Date			Fri 18 Jun 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::SendBackupRandomList(bool request)
{
	ULong n,packsize=sizeof(ULong) //PID
					+(RNDPACKETSIZE*sizeof(UWord));

	UByteP pack=new UByte[packsize];
	UByteP temp=pack;

	*(ULong*)temp=PID_RANDOMLIST;
	temp+=sizeof(ULong);

	for (n=0;n<(RNDPACKETSIZE);n++)
	{
		*(UWord*)temp=_Replay.BackupRndPacket[n];
		temp+=sizeof(UWord);
	}

	if (request)
	{
		SendMessageToPlayers((char*)pack,packsize);
	}
	else
	{
		SendGMessageToPlayers((char*)pack,packsize);
	}

// OK process the list myself now so that all players are same
	ProcessRandomList((char*)pack);

	delete [] pack;
}

//------------------------------------------------------------------------------
//Procedure		ProcessRandomList
//Author		Andy McMaster
//Date			Fri 18 Jun 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::ProcessRandomList(char* packet)
{
	UWord RndPacket [RNDPACKETSIZE];
	ULong n;

	packet+=sizeof(ULong); //skip PID

	for (n=0; n<RNDPACKETSIZE; n++)
	{
		RndPacket[n] = *(UWord*)packet;
		packet+=sizeof(UWord);
	}

	for (n=0; n<(RNDPACKETSIZE - 2); n++)
		Math_Lib.SetRndLookUp(n,RndPacket[n]);

	Math_Lib.Setbval(RndPacket[(RNDPACKETSIZE - 2)]);
	Math_Lib.Setcval(RndPacket[(RNDPACKETSIZE - 1)]);
}

//------------------------------------------------------------------------------
//Procedure		AddChatMessageToBuffer
//Author		Andy McMaster
//Date			Wed 22 Sep 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::AddChatMessageToBuffer(const char* name, const char* chat)
{
	strcpy(ChatBuffer.GetNext()->name,name);
	strcpy(ChatBuffer.GetNext()->chat,chat);

	ChatBuffer.AddEntryAndUpdateNext();

	if (ChatBuffer.GetNext()==ChatBuffer.GetCurr())
		ChatBuffer.UpdateCurr();
}

//------------------------------------------------------------------------------
//Procedure		UpdateChatBox
//Author		Andy McMaster
//Date			Wed 22 Sep 1999
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void DPlay::UpdateChatBox()
{
	ChatBuffer.SetTempCurr();

	while (ChatBuffer.GetTemp()!=ChatBuffer.GetNext())
	{
		if (H2H_Player[mySlot].status==CPS_READYROOM)
			DisplayReadyDialogue(ChatBuffer.GetTemp()->name,ChatBuffer.GetTemp()->chat);
#ifndef	MIG_DEMO_VER
		else if (H2H_Player[mySlot].status==CPS_FRAG)
			DisplayFragDialogue(ChatBuffer.GetTemp()->name,ChatBuffer.GetTemp()->chat);
#endif

		ChatBuffer.UpdateTemp();
	}
}

Bool DPlay::LobbyConnect()
{
	Bool res=TRUE;;
	
	if (lpDPL->ConnectEx(0,IID_IDirectPlay4A,(void**)&_DPlay.lpDP4,NULL)!=DP_OK)
		res=FALSE;

	if (!res)
	{
		lpDPL->Release();
		lpDPL=NULL;
		lpDP4=NULL;
	}
	else
	{
		res=_DPlay.SetUpPlayer();
	}

	return res;
}

void	DPlay::Process_PM_CSStruc(char* pack)
{
	ULong size,numparts;
	char* Buffer;
	ULong	BufferLen=0;
	ULong From,n;
	ULong rec=0;

	if (!Host)
	{
// mission has changed, unassign all player slots
		for (n=0;n<MAXPLAYERS;n++)
		{
			H2H_Player[n].squadron=-1;
			H2H_Player[n].position=-1;
		}

		MMC.playersquadron=-1;
		MMC.playeracnum=-1;

		if (H2H_Player[mySlot].status==CPS_FRAG)
			FragChanged=true;

// want to update mission name
		DisplayInfo=TRUE;
	}

	size=((PCOMMONDATA)pack)->Slot;
	numparts=((PCOMMONDATA)pack)->PlayerID;

// get parts
	UByte*	struc=new UByte[size];

	ULong now=timeGetTime();
	CommsTimeout time(now,(CommsTimeoutLength*2));

	while (rec!=numparts)
	{
		now=timeGetTime();

		if (time.TimedOut(now))
		{
			delete [] struc;
			return;
		}

		ULong to=0;
		if (ReceiveNextMessage (Buffer, BufferLen,From,to,0))
		{
// if we are getting info about game initally dont bother with any other messages
			if (From!=0 && BufferLen!=sizeof(AGGSENDPACKET))
			{
				if(((PCOMMONDATA)Buffer)->PacketID == PID_CSSTRUCBINARY)
				{
					LPCSSTRUCPART csp=(LPCSSTRUCPART)Buffer;

					GameIndex=csp->newmissionnum;

					UByteP temp=struc;

					temp+=(csp->index)*500;

					CopyMemory(temp,csp->data,csp->size);

					rec++;
				}
			}
		}
	}

	UpdateCSQuick((UByte*)struc,GameIndex);

	delete [] struc;
}

//------------------------------------------------------------------------------
//Procedure		CheckPacketSizes
//Author		Andy McMaster
//Date			Wed 28 Oct 1998
//
//Description	
//
//Inputs		
//
//Returns	
//
//------------------------------------------------------------------------------
void	DPlay::CheckPacketSizes()
{
	ULong size=sizeof(ACPACKET);

	if (size==sizeof(COMMONDATA))
		_Error.SayAndQuit("COMMONDATA same size as ACPACKET");

	if (size==sizeof(UILOOKUPTABLE))
		_Error.SayAndQuit("UILOOKUPTABLE same size as ACPACKET");

	if (size==sizeof(INITINFO))
		_Error.SayAndQuit("INITINFO same size as ACPACKET");

	if (size==sizeof(GAMEAVAILABLEPACKET))
		_Error.SayAndQuit("GAMEAVAILABLEPACKET same size as ACPACKET");

	if (size==sizeof(PASSWORDPACK))
		_Error.SayAndQuit("PASSWORDPACK same size as ACPACKET");

	if (size==sizeof(GAMEDETAILS))
		_Error.SayAndQuit("GAMEDETAILS same size as ACPACKET");

	if (size==sizeof(SLOTPOSPACK))
		_Error.SayAndQuit("SLOTPOSPACK same size as ACPACKET");

	if (size==sizeof(UIPREFSDATA))
		_Error.SayAndQuit("UIPREFSDATA same size as ACPACKET");

	if (size==sizeof(CONTROLPACKET))
		_Error.SayAndQuit("CONTROLPACKET same size as ACPACKET");

	if (size==sizeof(AGGREPLYPACKET))
		_Error.SayAndQuit("AGGREPLAYPACKET same size as ACPACKET");

	if (size==sizeof(ACSTATEPACKET))
		_Error.SayAndQuit("ACSTATEPACKET same size as ACPACKET");

	if (size==sizeof(ALLOCREQUEST))
		_Error.SayAndQuit("ALLOCREQUEST same size as ACPACKET");
}
